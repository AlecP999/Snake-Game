<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNAKE GAME</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bungee&family=Righteous&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Righteous', 'Arial Black', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #1a0033 0%, #0a0015 100%);
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(ellipse at center, #2a1a4a 0%, #1a0033 100%);
        }

        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0033 0%, #330066 50%, #1a0033 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .start-screen h1 {
            font-family: 'Bungee', cursive;
            font-size: 120px;
            background: linear-gradient(45deg, #ff0080, #ff8c00, #40e0d0, #ff0080);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            text-shadow: 0 0 80px rgba(255, 0, 128, 0.5);
            margin-bottom: 40px;
            letter-spacing: 8px;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes weaponGlow {
            0%, 100% { 
                box-shadow: 0 0 20px currentColor, 0 0 40px currentColor, inset 0 0 20px currentColor;
                transform: scale(1.1);
            }
            50% { 
                box-shadow: 0 0 30px currentColor, 0 0 60px currentColor, inset 0 0 30px currentColor;
                transform: scale(1.15);
            }
        }
        
        .weapon-slot.active {
            animation: weaponGlow 1s ease-in-out infinite;
            border-width: 3px !important;
            background: rgba(255, 255, 255, 0.3) !important;
        }
        
        .weapon-slot:hover {
            transform: scale(1.05);
            opacity: 0.8;
        }

        .start-screen input {
            padding: 20px 40px;
            font-size: 28px;
            font-family: 'Righteous', cursive;
            border: 4px solid #ff0080;
            background: rgba(0, 0, 0, 0.7);
            color: #40e0d0;
            border-radius: 50px;
            outline: none;
            text-align: center;
            margin-bottom: 15px;
            box-shadow: 0 0 30px rgba(255, 0, 128, 0.5);
            transition: all 0.3s ease;
        }

        .start-screen input[type="password"] {
            font-size: 20px;
            padding: 15px 30px;
        }

        .start-screen input:focus {
            border-color: #40e0d0;
            box-shadow: 0 0 50px rgba(64, 224, 208, 0.7);
        }

        .start-screen button {
            padding: 25px 80px;
            font-size: 32px;
            font-family: 'Bungee', cursive;
            background: linear-gradient(45deg, #ff0080, #ff8c00);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            box-shadow: 0 10px 40px rgba(255, 0, 128, 0.6);
        }

        .start-screen button:hover {
            transform: scale(1.1) translateY(-5px);
            box-shadow: 0 15px 60px rgba(255, 140, 0, 0.8);
        }
        
        .credits-button {
            transition: all 0.3s ease;
        }
        
        .credits-button:hover {
            transform: translateX(-50%) scale(1.1) translateY(-5px);
            box-shadow: 0 15px 60px rgba(160, 32, 240, 0.8);
        }

        .hud {
            position: fixed;
            top: 30px;
            left: 30px;
            font-size: 28px;
            color: #40e0d0;
            text-shadow: 0 0 20px rgba(64, 224, 208, 0.8);
            z-index: 100;
            pointer-events: none;
        }

        .hud div {
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 25px;
            border-radius: 20px;
            border: 2px solid #ff0080;
            display: inline-block;
        }

        .leaderboard {
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            border-radius: 20px;
            border: 3px solid #ff0080;
            color: #40e0d0;
            font-size: 20px;
            z-index: 100;
            pointer-events: none;
            min-width: 250px;
        }

        .leaderboard h3 {
            font-family: 'Bungee', cursive;
            text-align: center;
            margin-bottom: 15px;
            color: #ff0080;
            font-size: 24px;
        }

        .leaderboard-item {
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 0, 128, 0.1);
            border-radius: 10px;
        }

        .leaderboard-item.player {
            background: rgba(64, 224, 208, 0.2);
            border: 2px solid #40e0d0;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            pointer-events: auto;
        }

        .game-over h2 {
            font-family: 'Bungee', cursive;
            font-size: 80px;
            color: #ff0080;
            text-shadow: 0 0 40px rgba(255, 0, 128, 0.8);
            margin-bottom: 30px;
        }

        .game-over .stats {
            font-size: 32px;
            color: #40e0d0;
            margin: 15px 0;
        }

        .controls-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #40e0d0;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(64, 224, 208, 0.6);
            z-index: 100;
            text-align: center;
        }
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #ff8c00;
            border-radius: 20px;
            overflow: hidden;
            z-index: 100;
        }

        .boost-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0080, #ff8c00);
            width: 100%;
            transition: width 0.1s ease;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.8);
        }

        .controls-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #40e0d0;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(64, 224, 208, 0.6);
            z-index: 100;
            text-align: center;
        }

        .pause-button {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Bungee', 'Arial Black', sans-serif;
            background: linear-gradient(45deg, #ff0080, #ff8c00);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            z-index: 200;
            box-shadow: 0 5px 20px rgba(255, 0, 128, 0.5);
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        .pause-button:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 8px 30px rgba(255, 140, 0, 0.7);
        }

        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1500;
        }

        .pause-overlay h2 {
            font-family: 'Bungee', cursive;
            font-size: 80px;
            color: #40e0d0;
            text-shadow: 0 0 40px rgba(64, 224, 208, 0.8);
            margin-bottom: 40px;
        }

        .pause-overlay button {
            margin: 15px;
            padding: 20px 60px;
            font-size: 28px;
            font-family: 'Bungee', 'Arial Black', sans-serif;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        .pause-overlay .resume-btn {
            background: linear-gradient(45deg, #ff0080, #ff8c00);
            box-shadow: 0 10px 40px rgba(255, 0, 128, 0.6);
        }

        .pause-overlay .resume-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 60px rgba(255, 140, 0, 0.8);
        }

        .pause-overlay .home-btn {
            background: linear-gradient(45deg, #40e0d0, #00ffff);
            box-shadow: 0 10px 40px rgba(64, 224, 208, 0.6);
        }

        .pause-overlay .home-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 60px rgba(64, 224, 208, 0.8);
        }

        /* Dropdown styling with arrow */
        #gameMode {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='%2340e0d0' d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: calc(100% - 20px) center;
            background-size: 24px 24px;
            padding-right: 50px;
        }

        /* Mobile Joystick */
        .joystick-container {
            position: fixed;
            bottom: 80px;
            left: 80px;
            width: 150px;
            height: 150px;
            display: none;
            z-index: 150;
        }

        .joystick-base {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(64, 224, 208, 0.3);
            border: 3px solid #40e0d0;
            position: absolute;
            box-shadow: 0 0 20px rgba(64, 224, 208, 0.5);
        }

        .joystick-stick {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(145deg, #ff0080, #ff8c00);
            border: 3px solid white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 5px 15px rgba(255, 0, 128, 0.6);
            transition: all 0.1s ease;
        }

        .mobile-boost-button {
            position: fixed;
            bottom: 100px;
            right: 80px;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(145deg, #ff0080, #ff8c00);
            border: 4px solid white;
            display: none;
            justify-content: center;
            align-items: center;
            font-family: 'Bungee', 'Arial Black', sans-serif;
            color: white;
            font-size: 18px;
            z-index: 150;
            box-shadow: 0 5px 20px rgba(255, 0, 128, 0.7);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .mobile-boost-button:active {
            transform: scale(0.95);
            box-shadow: 0 3px 15px rgba(255, 0, 128, 0.9);
        }
    </style>
</head>
<body>
    <div class="start-screen" id="startScreen">
        <h1>SNAKE GAME</h1>
        <input type="text" id="playerName" placeholder="Enter Your Name" maxlength="15" />
        
        <!-- Game Mode Selector -->
        <select id="gameMode" onchange="toggleBotSettings()" style="margin-top: 15px; padding: 15px 30px; font-size: 18px; background: rgba(0,0,0,0.7); color: #40e0d0; border: 3px solid #ff0080; border-radius: 30px; cursor: pointer; font-family: 'Righteous', 'Arial Black', sans-serif; width: 300px; text-align: center; outline: none; appearance: none; -webkit-appearance: none; -moz-appearance: none;">
            <option value="ffa">FFA</option>
            <option value="suicide">SUICIDE</option>
            <option value="tdm">TDM</option>
            <option value="hardpoint">HARDPOINT</option>
            <option value="practice">PRACTICE RANGE</option>
            <option value="tournament">üèÜ TOURNAMENT</option>
        </select>
        
        <!-- Tournament Info Display -->
        <div id="tournamentInfo" style="display: none; margin-top: 20px; padding: 20px; background: rgba(0, 0, 0, 0.8); border: 3px solid #ffd700; border-radius: 15px; max-width: 400px; margin-left: auto; margin-right: auto;">
            <h3 style="color: #ffd700; font-family: 'Bungee', sans-serif; margin-bottom: 15px; font-size: 22px;">MONTHLY TOURNAMENT</h3>
            <div id="tournamentStatus" style="color: #40e0d0; font-family: 'Righteous', sans-serif; font-size: 16px; line-height: 1.8;"></div>
        </div>
        
        <!-- Bot Settings (shown for Practice Range) -->
        <div id="botSettings" style="display: none; margin-top: 20px;">
            <div style="margin-bottom: 15px;">
                <label style="color: #40e0d0; font-family: 'Righteous', sans-serif; font-size: 18px; display: block; margin-bottom: 8px;">Bot Amount:</label>
                <input type="range" id="botAmount" min="0" max="100" value="20" style="width: 280px;" oninput="document.getElementById('botAmountValue').textContent = this.value">
                <span id="botAmountValue" style="color: #ff0080; font-family: 'Bungee', sans-serif; font-size: 20px; margin-left: 10px;">20</span>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="color: #40e0d0; font-family: 'Righteous', sans-serif; font-size: 18px; display: block; margin-bottom: 8px;">Bot Difficulty:</label>
                <select id="botDifficulty" style="padding: 12px 25px; font-size: 16px; background: rgba(0,0,0,0.7); color: #40e0d0; border: 3px solid #ff0080; border-radius: 25px; cursor: pointer; font-family: 'Righteous', sans-serif; width: 280px; outline: none;">
                    <option value="easy">EASY - Passive</option>
                    <option value="medium" selected>MEDIUM - Normal</option>
                    <option value="hard">HARD - Aggressive</option>
                    <option value="insane">INSANE - Godlike</option>
                </select>
            </div>
        </div>
        
        <input type="password" id="adminCode" placeholder="Admin Code (Optional)" maxlength="6" style="margin-top: 15px;" />
        
        <button onclick="startGame()">SLITHER IN</button>
        <div style="margin-top: 20px;">
            <button onclick="showSignUp()" id="signUpButton" style="padding: 15px 30px; font-size: 18px; background: linear-gradient(45deg, #4285f4, #34a853); color: white; border: none; border-radius: 30px; cursor: pointer; font-family: 'Bungee', 'Arial Black', sans-serif; margin-right: 10px;">SIGN UP</button>
            <button onclick="showSignIn()" id="signInButton" style="padding: 15px 30px; font-size: 18px; background: linear-gradient(45deg, #40e0d0, #00ffff); color: white; border: none; border-radius: 30px; cursor: pointer; font-family: 'Bungee', 'Arial Black', sans-serif;">SIGN IN</button>
        </div>
        <p id="accountStatus" style="margin-top: 15px; color: #40e0d0; font-size: 18px;"></p>
        
        <!-- Credits Button -->
        <button onclick="showCredits()" class="credits-button" style="position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); padding: 10px 25px; font-size: 16px; background: linear-gradient(45deg, #8b008b, #a020f0); color: white; border: none; border-radius: 20px; cursor: pointer; font-family: 'Bungee', 'Arial Black', sans-serif;">CREDITS</button>
    </div>

    <!-- Credits Modal -->
    <div id="creditsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 2000; justify-content: center; align-items: center;">
        <div style="background: linear-gradient(135deg, #1a0033 0%, #330066 50%, #1a0033 100%); padding: 50px; border-radius: 20px; border: 3px solid #a020f0; text-align: center;">
            <h2 style="font-family: 'Bungee', 'Arial Black', sans-serif; color: #a020f0; margin-bottom: 30px; font-size: 36px;">CREDITS</h2>
            <p style="font-family: 'Righteous', 'Arial Black', sans-serif; color: #40e0d0; font-size: 22px; line-height: 1.8;">
                <strong style="color: #ff0080;">Code & Game:</strong> Alec & Claude AI<br>
                <strong style="color: #ff0080;">More Ideas:</strong> Leonardo (Venom Feature)
            </p>
            <button onclick="closeCredits()" style="padding: 15px 40px; font-size: 20px; background: linear-gradient(45deg, #ff0080, #ff8c00); color: white; border: none; border-radius: 30px; cursor: pointer; font-family: 'Bungee', 'Arial Black', sans-serif; margin-top: 30px;">CLOSE</button>
        </div>
    </div>

    <!-- Sign Up Modal -->
    <div id="signUpModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 2000; justify-content: center; align-items: center;">
        <div style="background: linear-gradient(135deg, #1a0033 0%, #330066 50%, #1a0033 100%); padding: 40px; border-radius: 20px; border: 3px solid #ff0080; text-align: center;">
            <h2 style="font-family: 'Bungee', 'Arial Black', sans-serif; color: #40e0d0; margin-bottom: 30px;">CREATE ACCOUNT</h2>
            <input type="text" id="signUpUsername" placeholder="Username" maxlength="20" style="display: block; width: 300px; padding: 15px; margin: 15px auto; font-size: 18px; border: 2px solid #ff0080; background: rgba(0,0,0,0.5); color: #40e0d0; border-radius: 10px; font-family: 'Righteous', 'Arial Black', sans-serif;" />
            <input type="password" id="signUpPassword" placeholder="Password" maxlength="30" style="display: block; width: 300px; padding: 15px; margin: 15px auto; font-size: 18px; border: 2px solid #ff0080; background: rgba(0,0,0,0.5); color: #40e0d0; border-radius: 10px; font-family: 'Righteous', 'Arial Black', sans-serif;" />
            <input type="password" id="signUpConfirm" placeholder="Confirm Password" maxlength="30" style="display: block; width: 300px; padding: 15px; margin: 15px auto; font-size: 18px; border: 2px solid #ff0080; background: rgba(0,0,0,0.5); color: #40e0d0; border-radius: 10px; font-family: 'Righteous', 'Arial Black', sans-serif;" />
            <button onclick="createAccount()" style="padding: 15px 40px; font-size: 20px; background: linear-gradient(45deg, #ff0080, #ff8c00); color: white; border: none; border-radius: 30px; cursor: pointer; font-family: 'Bungee', 'Arial Black', sans-serif; margin-top: 20px; margin-right: 10px;">CREATE</button>
            <button onclick="closeSignUp()" style="padding: 15px 40px; font-size: 20px; background: linear-gradient(45deg, #666, #888); color: white; border: none; border-radius: 30px; cursor: pointer; font-family: 'Bungee', 'Arial Black', sans-serif; margin-top: 20px;">CANCEL</button>
        </div>
    </div>

    <!-- Sign In Modal -->
    <div id="signInModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 2000; justify-content: center; align-items: center;">
        <div style="background: linear-gradient(135deg, #1a0033 0%, #330066 50%, #1a0033 100%); padding: 40px; border-radius: 20px; border: 3px solid #40e0d0; text-align: center;">
            <h2 style="font-family: 'Bungee', 'Arial Black', sans-serif; color: #40e0d0; margin-bottom: 30px;">SIGN IN</h2>
            <input type="text" id="signInUsername" placeholder="Username" maxlength="20" style="display: block; width: 300px; padding: 15px; margin: 15px auto; font-size: 18px; border: 2px solid #40e0d0; background: rgba(0,0,0,0.5); color: #40e0d0; border-radius: 10px; font-family: 'Righteous', 'Arial Black', sans-serif;" />
            <input type="password" id="signInPassword" placeholder="Password" maxlength="30" style="display: block; width: 300px; padding: 15px; margin: 15px auto; font-size: 18px; border: 2px solid #40e0d0; background: rgba(0,0,0,0.5); color: #40e0d0; border-radius: 10px; font-family: 'Righteous', 'Arial Black', sans-serif;" />
            <button onclick="signInAccount()" style="padding: 15px 40px; font-size: 20px; background: linear-gradient(45deg, #40e0d0, #00ffff); color: white; border: none; border-radius: 30px; cursor: pointer; font-family: 'Bungee', 'Arial Black', sans-serif; margin-top: 20px; margin-right: 10px;">SIGN IN</button>
            <button onclick="closeSignIn()" style="padding: 15px 40px; font-size: 20px; background: linear-gradient(45deg, #666, #888); color: white; border: none; border-radius: 30px; cursor: pointer; font-family: 'Bungee', 'Arial Black', sans-serif; margin-top: 20px;">CANCEL</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="hud" id="hud" style="display: none;">
        <div><span id="length">10</span></div>
        <div>Rank: <span id="rank">#1</span></div>
        <div id="weaponDisplay" style="margin-top: 10px; font-size: 18px; color: #ffd700;">Weapon: <span id="weaponName">VENOM</span></div>
    </div>

    <div class="leaderboard" id="leaderboard" style="display: none;">
        <h3>TOP SNAKES</h3>
        <div id="leaderboardList"></div>
    </div>

    <div class="boost-indicator" id="boostIndicator" style="display: none;">
        <div class="boost-bar" id="boostBar"></div>
    </div>

    <div class="controls-hint" id="controlsHint" style="display: none;">
        Move mouse to control ‚Ä¢ Click to boost ‚Ä¢ SPACE/E to fire ‚Ä¢ ESC to pause ‚Ä¢ 1-7 to switch weapons
    </div>
    
    <!-- Weapons Bar -->
    <div id="weaponsBar" style="display: none; position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); padding: 15px 20px; border-radius: 15px; border: 3px solid #40e0d0; display: flex; gap: 15px; z-index: 100;">
        <div class="weapon-slot" data-weapon="1" style="position: relative; width: 60px; height: 60px; background: rgba(139, 0, 139, 0.3); border: 2px solid #a020f0; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s;">
            <div style="font-size: 30px; margin-bottom: 3px;">üíú</div>
            <div style="font-size: 10px; color: #fff; font-family: 'Bungee', sans-serif;">1</div>
        </div>
        <div class="weapon-slot" data-weapon="2" style="position: relative; width: 60px; height: 60px; background: rgba(0, 255, 255, 0.2); border: 2px solid #00ffff; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s;">
            <div style="font-size: 30px; margin-bottom: 3px;">‚ö°</div>
            <div style="font-size: 10px; color: #fff; font-family: 'Bungee', sans-serif;">2</div>
        </div>
        <div class="weapon-slot" data-weapon="3" style="position: relative; width: 60px; height: 60px; background: rgba(255, 69, 0, 0.2); border: 2px solid #ff4500; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s;">
            <div style="font-size: 30px; margin-bottom: 3px;">üí£</div>
            <div style="font-size: 10px; color: #fff; font-family: 'Bungee', sans-serif;">3</div>
        </div>
        <div class="weapon-slot" data-weapon="4" style="position: relative; width: 60px; height: 60px; background: rgba(255, 0, 0, 0.2); border: 2px solid #ff0000; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s;">
            <div style="font-size: 30px; margin-bottom: 3px;">üí•</div>
            <div style="font-size: 10px; color: #fff; font-family: 'Bungee', sans-serif;">4</div>
        </div>
        <div class="weapon-slot" data-weapon="5" style="position: relative; width: 60px; height: 60px; background: rgba(255, 165, 0, 0.2); border: 2px solid #ffa500; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s;">
            <div style="font-size: 30px; margin-bottom: 3px;">ü™ù</div>
            <div style="font-size: 10px; color: #fff; font-family: 'Bungee', sans-serif;">5</div>
        </div>
        <div class="weapon-slot" data-weapon="6" style="position: relative; width: 60px; height: 60px; background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd700; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s;">
            <div style="font-size: 30px; margin-bottom: 3px;">üí®</div>
            <div style="font-size: 10px; color: #fff; font-family: 'Bungee', sans-serif;">6</div>
        </div>
        <div class="weapon-slot" data-weapon="7" style="position: relative; width: 60px; height: 60px; background: rgba(0, 255, 0, 0.2); border: 2px solid #00ff00; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s;">
            <div style="font-size: 30px; margin-bottom: 3px;">‚ò†Ô∏è</div>
            <div style="font-size: 10px; color: #fff; font-family: 'Bungee', sans-serif;">7</div>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div class="joystick-container" id="joystick">
        <div class="joystick-base"></div>
        <div class="joystick-stick" id="joystickStick"></div>
    </div>

    <div class="mobile-boost-button" id="mobileBoost">BOOST</div>
    
    <div class="mobile-boost-button" id="mobileVenom" style="right: 200px; background: linear-gradient(145deg, #a020f0, #8b008b);">VENOM</div>

    <button class="pause-button" id="pauseButton" style="display: none;" onclick="togglePause()">PAUSE</button>

    <div class="pause-overlay" id="pauseOverlay">
        <h2>PAUSED</h2>
        <button class="resume-btn" onclick="togglePause()">RESUME</button>
    </div>

    <div class="game-over" id="gameOver">
        <h2>GAME OVER</h2>
        <div class="stats" id="finalStats"></div>
        <button onclick="location.reload()" style="margin-top: 40px; padding: 20px 60px; font-size: 28px; font-family: 'Bungee', cursive; background: linear-gradient(45deg, #ff0080, #ff8c00); color: white; border: none; border-radius: 50px; cursor: pointer;">PLAY AGAIN</button>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Fake Account System with Sign Up and Sign In
        let currentLoggedInUser = localStorage.getItem('loggedInUser') || null;
        
        // Get all accounts from localStorage
        function getAccounts() {
            const accounts = localStorage.getItem('fakeAccounts');
            return accounts ? JSON.parse(accounts) : {};
        }
        
        // Save accounts to localStorage
        function saveAccounts(accounts) {
            localStorage.setItem('fakeAccounts', JSON.stringify(accounts));
        }
        
        // Update UI based on login status
        function updateAccountUI() {
            const accountStatus = document.getElementById('accountStatus');
            const signUpButton = document.getElementById('signUpButton');
            const signInButton = document.getElementById('signInButton');
            
            if (currentLoggedInUser) {
                accountStatus.textContent = `Logged in as: ${currentLoggedInUser}`;
                signUpButton.style.display = 'none';
                signInButton.textContent = 'SIGN OUT';
                signInButton.style.background = 'linear-gradient(45deg, #ff0080, #ff8c00)';
                signInButton.onclick = signOutAccount;
            } else {
                accountStatus.textContent = '';
                signUpButton.style.display = 'inline-block';
                signInButton.textContent = 'SIGN IN';
                signInButton.style.background = 'linear-gradient(45deg, #40e0d0, #00ffff)';
                signInButton.onclick = showSignIn;
            }
        }
        
        // Show sign up modal
        function showSignUp() {
            document.getElementById('signUpModal').style.display = 'flex';
            document.getElementById('signUpUsername').value = '';
            document.getElementById('signUpPassword').value = '';
            document.getElementById('signUpConfirm').value = '';
        }
        
        // Close sign up modal
        function closeSignUp() {
            document.getElementById('signUpModal').style.display = 'none';
        }
        
        // Create account
        function createAccount() {
            const username = document.getElementById('signUpUsername').value.trim();
            const password = document.getElementById('signUpPassword').value;
            const confirm = document.getElementById('signUpConfirm').value;
            
            if (!username) {
                alert('Please enter a username');
                return;
            }
            
            if (!password) {
                alert('Please enter a password');
                return;
            }
            
            if (password !== confirm) {
                alert('Passwords do not match');
                return;
            }
            
            const accounts = getAccounts();
            
            if (accounts[username]) {
                alert('Username already exists');
                return;
            }
            
            // Create account
            accounts[username] = password;
            saveAccounts(accounts);
            
            // Log sign-up info (no real IP available, but we can log browser info)
            const signUpInfo = {
                username: username,
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                language: navigator.language,
                platform: navigator.platform,
                screenResolution: `${window.screen.width}x${window.screen.height}`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
            };
            
            // Store in localStorage for viewing
            let signUpLogs = JSON.parse(localStorage.getItem('signUpLogs') || '[]');
            signUpLogs.push(signUpInfo);
            localStorage.setItem('signUpLogs', JSON.stringify(signUpLogs));
            
            console.log('SIGN UP INFO:', signUpInfo);
            
            // Auto sign in
            currentLoggedInUser = username;
            localStorage.setItem('loggedInUser', username);
            updateAccountUI();
            closeSignUp();
            
            alert('Account created and signed in successfully!');
        }
        
        // Show sign in modal
        function showSignIn() {
            document.getElementById('signInModal').style.display = 'flex';
            document.getElementById('signInUsername').value = '';
            document.getElementById('signInPassword').value = '';
        }
        
        // Close sign in modal
        function closeSignIn() {
            document.getElementById('signInModal').style.display = 'none';
        }
        
        function showCredits() {
            document.getElementById('creditsModal').style.display = 'flex';
        }
        
        function closeCredits() {
            document.getElementById('creditsModal').style.display = 'none';
        }
        
        function toggleBotSettings() {
            const gameMode = document.getElementById('gameMode').value;
            const botSettings = document.getElementById('botSettings');
            const tournamentInfo = document.getElementById('tournamentInfo');
            
            if (gameMode === 'practice') {
                botSettings.style.display = 'block';
                tournamentInfo.style.display = 'none';
            } else if (gameMode === 'tournament') {
                botSettings.style.display = 'none';
                tournamentInfo.style.display = 'block';
                updateTournamentDisplay();
            } else {
                botSettings.style.display = 'none';
                tournamentInfo.style.display = 'none';
            }
        }
        
        function updateTournamentDisplay() {
            // Get current tournament progress from localStorage
            const tournamentData = JSON.parse(localStorage.getItem('tournamentProgress') || '{}');
            const currentMonth = new Date().getMonth() + '-' + new Date().getFullYear();
            
            // Reset tournament if new month
            if (tournamentData.month !== currentMonth) {
                tournamentData.month = currentMonth;
                tournamentData.stage = 'qualifier';
                tournamentData.qualified = false;
                tournamentData.hasPlayed = false; // Reset play limit
                localStorage.setItem('tournamentProgress', JSON.stringify(tournamentData));
            }
            
            tournamentMonth = currentMonth;
            tournamentStage = tournamentData.stage || 'qualifier';
            
            const statusDiv = document.getElementById('tournamentStatus');
            
            let stageText = '';
            let requirements = '';
            
            switch(tournamentStage) {
                case 'qualifier':
                    stageText = 'üìã QUALIFIER ROUND';
                    requirements = 'Finish TOP 10 to advance to Quarter-Finals';
                    break;
                case 'quarters':
                    stageText = 'ü•â QUARTER-FINALS';
                    requirements = 'Finish TOP 10 to advance to Semi-Finals';
                    break;
                case 'semis':
                    stageText = 'ü•à SEMI-FINALS';
                    requirements = 'Finish TOP 7 to advance to Finals';
                    break;
                case 'finals':
                    stageText = 'ü•á FINALS';
                    requirements = 'Finish 1ST PLACE to WIN TOURNAMENT';
                    break;
            }
            
            // Check if already played this month
            let playStatus = '';
            if (tournamentData.hasPlayed) {
                playStatus = '<div style="color: #ff0000; font-size: 16px; margin-top: 15px; padding: 10px; background: rgba(255, 0, 0, 0.2); border: 2px solid #ff0000; border-radius: 10px;">‚ö†Ô∏è ALREADY PLAYED THIS MONTH<br><span style="font-size: 14px;">Wait until next month or use ADMIN code</span></div>';
            }
            
            statusDiv.innerHTML = `
                <div style="margin-bottom: 10px;"><strong>${stageText}</strong></div>
                <div style="margin-bottom: 10px;">Month: ${getMonthName(new Date().getMonth())}</div>
                <div style="margin-bottom: 10px;">Players: 40 AI + You</div>
                <div style="margin-bottom: 10px;">Mode: Hardpoint</div>
                <div style="color: #ffd700; font-size: 18px; margin-top: 15px;"><strong>${requirements}</strong></div>
                ${tournamentStage === 'finals' ? '<div style="color: #ff0080; margin-top: 10px; font-size: 14px;">Win Finals to receive ADMIN CODE!</div>' : ''}
                ${playStatus}
            `;
        }
        
        function getMonthName(month) {
            const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                          'July', 'August', 'September', 'October', 'November', 'December'];
            return months[month];
        }
        
        function isHardpointMode() {
            return gameMode === 'hardpoint' || gameMode === 'tournament';
        }
        
        function shouldRespawn() {
            // No respawning in battleroyale, hardpoint, or tournament
            return gameMode !== 'battleroyale' && gameMode !== 'hardpoint' && gameMode !== 'tournament';
        }
        
        // Sign in to account
        function signInAccount() {
            const username = document.getElementById('signInUsername').value.trim();
            const password = document.getElementById('signInPassword').value;
            
            if (!username || !password) {
                alert('Please enter username and password');
                return;
            }
            
            const accounts = getAccounts();
            
            if (!accounts[username]) {
                alert('Account not found');
                return;
            }
            
            if (accounts[username] !== password) {
                alert('Incorrect password');
                return;
            }
            
            // Log sign-in info
            const signInInfo = {
                username: username,
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                language: navigator.language,
                platform: navigator.platform,
                screenResolution: `${window.screen.width}x${window.screen.height}`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
            };
            
            // Store in localStorage for viewing
            let signInLogs = JSON.parse(localStorage.getItem('signInLogs') || '[]');
            signInLogs.push(signInInfo);
            localStorage.setItem('signInLogs', JSON.stringify(signInLogs));
            
            console.log('SIGN IN INFO:', signInInfo);
            
            // Sign in successful
            currentLoggedInUser = username;
            localStorage.setItem('loggedInUser', username);
            updateAccountUI();
            closeSignIn();
            alert('Signed in successfully!');
        }
        
        // Sign out
        function signOutAccount() {
            currentLoggedInUser = null;
            localStorage.removeItem('loggedInUser');
            updateAccountUI();
            alert('Signed out successfully!');
        }
        
        // Update UI on page load
        window.addEventListener('DOMContentLoaded', updateAccountUI);

        let gameStarted = false;
        let gameOver = false;
        let isPaused = false;
        let playerName = '';
        let isAdmin = false;
        let adminImmune = false; // Admin immunity toggle
        let gameMode = 'ffa'; // Current game mode
        let botAmount = 20; // Custom bot amount for practice
        let botDifficulty = 'medium'; // Bot difficulty level
        
        // Tournament system
        let tournamentStage = 'qualifier'; // qualifier, quarters, semis, finals
        let tournamentMonth = null; // Current tournament month
        const TOURNAMENT_AI_COUNT = 40; // Always 40 AI in tournament
        const ADMIN_CODE_REVEAL = '268459'; // Code revealed when winning finals
        const ADMIN_CODE = '268459';
        const UNBAN_CODE = 'UNBANALL';
        
        // Session tracking (IP tracking not available due to network restrictions)
        let sessionID = localStorage.getItem('snakeGameSessionID') || 'Session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('snakeGameSessionID', sessionID);
        console.log('Session ID:', sessionID);
        
        // Venom projectiles
        let venomShots = [];
        let venomCooldown = 0;
        const VENOM_COOLDOWN_TIME = 120; // 2 seconds at 60fps (reduced from 3)
        
        // New weapons
        let laserBeams = [];
        let laserCooldown = 0;
        const LASER_COOLDOWN_TIME = 180; // 3 seconds
        
        let explosiveShots = [];
        let explosiveCooldown = 0;
        const EXPLOSIVE_COOLDOWN_TIME = 240; // 4 seconds
        
        let mines = [];
        let mineCooldown = 0;
        const MINE_COOLDOWN_TIME = 120; // 2 seconds
        
        let hooks = [];
        let hookCooldown = 0;
        const HOOK_COOLDOWN_TIME = 180; // 3 seconds
        
        let dashCooldown = 0;
        const DASH_COOLDOWN_TIME = 180; // 3 seconds
        
        let poisonTrailActive = false;
        let poisonTrailSegments = [];
        let poisonTrailCooldown = 0;
        const POISON_TRAIL_COOLDOWN_TIME = 300; // 5 seconds
        
        // Current weapon (1-7)
        let currentWeapon = 1; // 1=Venom, 2=Laser, 3=Explosive, 4=Mine, 5=Hook, 6=Dash, 7=Poison Trail

        // Mobile detection and controls
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        let joystickActive = false;
        let joystickAngle = 0;
        let joystickDistance = 0;

        // Joystick touch and mouse controls
        const joystick = document.getElementById('joystick');
        const joystickStick = document.getElementById('joystickStick');

        // Touch events
        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            handleJoystickMove(e);
        });

        joystick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickActive) {
                handleJoystickMove(e);
            }
        });

        joystick.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickActive = false;
            joystickDistance = 0;
            joystickStick.style.transform = 'translate(-50%, -50%)';
        });

        // Mouse events for PC
        joystick.addEventListener('mousedown', (e) => {
            e.preventDefault();
            joystickActive = true;
            handleJoystickMouseMove(e);
        });

        document.addEventListener('mousemove', (e) => {
            if (joystickActive) {
                handleJoystickMouseMove(e);
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (joystickActive) {
                joystickActive = false;
                joystickDistance = 0;
                joystickStick.style.transform = 'translate(-50%, -50%)';
            }
        });

        function handleJoystickMove(e) {
            const touch = e.touches[0];
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;
            
            joystickAngle = Math.atan2(dy, dx);
            joystickDistance = Math.min(Math.sqrt(dx * dx + dy * dy), 45);
            
            const stickX = Math.cos(joystickAngle) * joystickDistance;
            const stickY = Math.sin(joystickAngle) * joystickDistance;
            
            joystickStick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;
        }

        function handleJoystickMouseMove(e) {
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const dx = e.clientX - centerX;
            const dy = e.clientY - centerY;
            
            joystickAngle = Math.atan2(dy, dx);
            joystickDistance = Math.min(Math.sqrt(dx * dx + dy * dy), 45);
            
            const stickX = Math.cos(joystickAngle) * joystickDistance;
            const stickY = Math.sin(joystickAngle) * joystickDistance;
            
            joystickStick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;
        }

        // Boost button - touch and mouse events
        const mobileBoost = document.getElementById('mobileBoost');
        
        // Touch events
        mobileBoost.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (player && !gameOver && !isPaused) {
                player.boosting = true;
            }
        });

        mobileBoost.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (player) {
                player.boosting = false;
            }
        });

        // Mouse events for PC
        mobileBoost.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (player && !gameOver && !isPaused) {
                player.boosting = true;
            }
        });

        mobileBoost.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (player) {
                player.boosting = false;
            }
        });
        
        // Venom button - touch and mouse events
        const mobileVenom = document.getElementById('mobileVenom');
        
        // Touch events
        mobileVenom.addEventListener('touchstart', (e) => {
            e.preventDefault();
            fireWeapon();
        });

        // Mouse events for PC
        mobileVenom.addEventListener('mousedown', (e) => {
            e.preventDefault();
            fireWeapon();
        });
        
        // Check if user is banned
        function checkBan() {
            const banned = localStorage.getItem('snakeGameBanned');
            const banReason = localStorage.getItem('snakeGameBanReason') || 'Invalid admin code attempt';
            
            if (banned === 'true') {
                document.body.innerHTML = `
                    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                                background: linear-gradient(135deg, #1a0033 0%, #330066 50%, #1a0033 100%);
                                display: flex; flex-direction: column; justify-content: center; align-items: center;
                                font-family: 'Bungee', cursive; color: #ff0055;">
                        <h1 style="font-size: 80px; margin-bottom: 30px;">BANNED</h1>
                        <p style="font-size: 24px; color: #40e0d0;">You have been permanently banned from this game.</p>
                        <p style="font-size: 18px; color: #888; margin-top: 20px;">Reason: ${banReason}</p>
                        <input type="text" id="unbanInput" placeholder="Unban Code" 
                               style="margin-top: 40px; padding: 15px 30px; font-size: 20px; 
                                      background: rgba(0,0,0,0.7); color: #40e0d0; border: 3px solid #ff0080;
                                      border-radius: 30px; text-align: center; outline: none;" />
                        <button onclick="checkUnban()" 
                                style="margin-top: 20px; padding: 15px 40px; font-size: 20px;
                                       background: linear-gradient(45deg, #ff0080, #ff8c00); color: white;
                                       border: none; border-radius: 30px; cursor: pointer; font-family: 'Bungee', cursive;">
                            SUBMIT
                        </button>
                    </div>
                `;
                
                // Add unban check function to window
                window.checkUnban = function() {
                    const input = document.getElementById('unbanInput');
                    if (input.value === UNBAN_CODE) {
                        localStorage.removeItem('snakeGameBanned');
                        localStorage.removeItem('snakeGameBanReason');
                        location.reload();
                    } else {
                        alert('Invalid unban code');
                    }
                };
                
                throw new Error('User is banned');
            }
        }
        
        function banUser() {
            localStorage.setItem('snakeGameBanned', 'true');
            localStorage.setItem('snakeGameBanReason', 'Invalid admin code attempt');
            
            // Log ban with session ID
            const banLog = JSON.parse(localStorage.getItem('snakeGameBanLog') || '[]');
            banLog.push({
                sessionID: sessionID,
                reason: 'Invalid admin code attempt',
                timestamp: new Date().toISOString()
            });
            localStorage.setItem('snakeGameBanLog', JSON.stringify(banLog));
            console.log('User banned - Session:', sessionID);
            
            document.body.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                            background: linear-gradient(135deg, #1a0033 0%, #330066 50%, #1a0033 100%);
                            display: flex; flex-direction: column; justify-content: center; align-items: center;
                            font-family: 'Bungee', cursive; color: #ff0055; animation: banFlash 0.5s;">
                    <h1 style="font-size: 100px; margin-bottom: 30px; text-shadow: 0 0 50px rgba(255, 0, 85, 0.8);">BANNED</h1>
                    <p style="font-size: 32px; color: #40e0d0;">You entered an incorrect admin code.</p>
                    <p style="font-size: 24px; color: #ff8c00; margin-top: 20px;">You are now permanently banned from this game.</p>
                    <p style="font-size: 18px; color: #888; margin-top: 40px;">Reason: Invalid admin code attempt</p>
                    <input type="text" id="unbanInput" placeholder="Unban Code" 
                           style="margin-top: 40px; padding: 15px 30px; font-size: 20px; 
                                  background: rgba(0,0,0,0.7); color: #40e0d0; border: 3px solid #ff0080;
                                  border-radius: 30px; text-align: center; outline: none;" />
                    <button onclick="checkUnbanDirect()" 
                            style="margin-top: 20px; padding: 15px 40px; font-size: 20px;
                                   background: linear-gradient(45deg, #ff0080, #ff8c00); color: white;
                                   border: none; border-radius: 30px; cursor: pointer; font-family: 'Bungee', cursive;">
                        SUBMIT
                    </button>
                </div>
                <style>
                    @keyframes banFlash {
                        0%, 100% { background-color: rgba(255, 0, 0, 0.1); }
                        50% { background-color: rgba(255, 0, 0, 0.3); }
                    }
                </style>
            `;
            
            // Add unban check function
            window.checkUnbanDirect = function() {
                const input = document.getElementById('unbanInput');
                if (input.value === 'UNBANALL') {
                    localStorage.removeItem('snakeGameBanned');
                    location.reload();
                } else {
                    alert('Invalid unban code');
                }
            };
        }
        
        // Check ban on load
        checkBan();

        // Game world
        const WORLD_WIDTH = 4000;
        const WORLD_HEIGHT = 4000;
        
        // Camera
        let camera = { x: 0, y: 0 };

        // Player snake
        let player = null;

        // AI snakes
        let snakes = [];

        // Food
        let food = [];
        const FOOD_COUNT = 300;
        const PURPLE_FOOD_COUNT = 5;
        
        // Hardpoint zone
        let hardpoint = {
            x: WORLD_WIDTH / 2,
            y: WORLD_HEIGHT / 2,
            radius: 120, // Reduced from 200 - smaller zone = more intense
            nextMoveTime: Date.now() + 20000, // Move every 20 seconds (was 30)
            glowPhase: 0
        };
        let hardpointScore = { player: 0, ai: 0 };
        let playerInZone = false;
        let playerOutsideTimer = 0; // Track how long player has been outside
        let playerMultiplier = 1; // Current scoring multiplier
        let playerZoneTime = 0; // Frames in zone
        
        // Battle Royale storm
        let storm = {
            x: WORLD_WIDTH / 2,
            y: WORLD_HEIGHT / 2,
            currentRadius: WORLD_WIDTH,
            targetRadius: WORLD_WIDTH * 0.9,
            shrinkStage: 0,
            maxStages: 12,
            pauseUntil: 0,
            isMoving: false,
            targetX: WORLD_WIDTH / 2,
            targetY: WORLD_HEIGHT / 2,
            damageTimer: 0
        };
        const STORM_SHRINK_TIMES = [20000, 20000, 20000, 20000, 15000, 15000, 10000, 10000, 10000, 5000, 5000, 5000]; // Time between shrinks

        // Colors
        const SNAKE_COLORS = [
            ['#ff0080', '#ff69b4'],
            ['#40e0d0', '#00ffff'],
            ['#ff8c00', '#ffd700'],
            ['#9370db', '#ba55d3'],
            ['#00ff00', '#7fff00'],
            ['#ff1493', '#ff69b4'],
            ['#1e90ff', '#00bfff'],
        ];

        const FOOD_COLORS = ['#fff', '#ffe', '#fef', '#eff'];
        const PURPLE_FOOD_COLOR = '#a020f0';

        // Snake names
        const SNAKE_NAMES = [
            'Viper', 'Cobra', 'Python', 'Mamba', 'Anaconda',
            'Rattler', 'Boa', 'Adder', 'Venom', 'Fang',
            'Slither', 'Coil', 'Scales', 'Hiss', 'Strike'
        ];

        // Profanity filter
        const BANNED_WORDS = [
            'fuck', 'shit', 'damn', 'bitch', 'ass', 'hell', 'crap',
            'dick', 'cock', 'pussy', 'penis', 'vagina', 'sex', 'porn',
            'kill', 'die', 'death', 'murder', 'rape', 'nazi', 'hitler',
            'nigger', 'nigga', 'fag', 'retard', 'cancer', 'kys'
        ];

        function moderateName(name) {
            // Convert to lowercase for checking
            const lowerName = name.toLowerCase();
            
            // Check for banned words
            for (let word of BANNED_WORDS) {
                if (lowerName.includes(word)) {
                    return false;
                }
            }
            
            // Check for excessive special characters
            const specialCharCount = (name.match(/[^a-zA-Z0-9 ]/g) || []).length;
            if (specialCharCount > 3) {
                return false;
            }
            
            // Check for too many numbers
            const numberCount = (name.match(/[0-9]/g) || []).length;
            if (numberCount > name.length / 2) {
                return false;
            }
            
            return true;
        }

        class Snake {
            constructor(x, y, isPlayer = false, name = '', team = null) {
                this.segments = [];
                this.isPlayer = isPlayer;
                this.name = name || SNAKE_NAMES[Math.floor(Math.random() * SNAKE_NAMES.length)] + Math.floor(Math.random() * 100);
                this.team = team; // 'red' or 'blue' or null
                this.difficulty = 'medium'; // AI difficulty: easy, medium, hard, insane
                
                // Spawn protection - 2 seconds of invincibility
                this.spawnProtection = true;
                this.spawnProtectionTime = 120; // 2 seconds at 60fps
                
                // Team colors for TDM mode
                if (team === 'red') {
                    this.colors = ['#ff0080', '#ff1493']; // Red/Pink team
                } else if (team === 'blue') {
                    this.colors = ['#00bfff', '#1e90ff']; // Blue team
                } else {
                    this.colors = SNAKE_COLORS[Math.floor(Math.random() * SNAKE_COLORS.length)];
                }
                
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 3.5; // Increased from 3
                this.segmentRadius = 8;
                this.length = 10;
                this.boost = 100;
                this.maxBoost = 100;
                this.boosting = false;
                this.targetX = x;
                this.targetY = y;

                // Initialize segments
                for (let i = 0; i < this.length; i++) {
                    this.segments.push({
                        x: x - i * this.segmentRadius * 2,
                        y: y,
                        radius: this.segmentRadius
                    });
                }
            }

            update(mouseX, mouseY) {
                // Countdown spawn protection
                if (this.spawnProtection && this.spawnProtectionTime > 0) {
                    this.spawnProtectionTime--;
                    if (this.spawnProtectionTime <= 0) {
                        this.spawnProtection = false;
                    }
                }
                
                // Update angle based on target
                if (this.isPlayer && gameStarted) {
                    // Use joystick if active, otherwise use mouse
                    if (joystickActive && joystickDistance > 5) {
                        // Use joystick angle directly
                        this.angle = joystickAngle;
                    } else {
                        // Use mouse control
                        const worldMouseX = mouseX + camera.x;
                        const worldMouseY = mouseY + camera.y;
                        const dx = worldMouseX - this.segments[0].x;
                        const dy = worldMouseY - this.segments[0].y;
                        const targetAngle = Math.atan2(dy, dx);
                        
                        // Smooth angle transition for less blocky movement
                        let angleDiff = targetAngle - this.angle;
                        // Normalize angle difference to -PI to PI range
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        // Interpolate angle for smoother turning
                        this.angle += angleDiff * 0.15;
                    }
                } else if (!this.isPlayer) {
                    // AI behavior
                    this.updateAI();
                }

                // Handle boosting
                if (this.boosting && this.boost > 0) {
                    this.boost -= 1;
                    this.speed = 7; // Increased from 6
                    
                    // Admin has infinite boost
                    if (this.isPlayer && isAdmin) {
                        this.boost = this.maxBoost; // Keep boost full
                    }
                } else {
                    this.boosting = false;
                    this.speed = 3.5; // Increased from 3
                    if (this.boost < this.maxBoost) {
                        this.boost += 0.5; // Increased from 0.3 - faster recharge
                    }
                }

                // Move head
                const head = this.segments[0];
                head.x += Math.cos(this.angle) * this.speed;
                head.y += Math.sin(this.angle) * this.speed;

                // Keep in bounds
                head.x = Math.max(50, Math.min(WORLD_WIDTH - 50, head.x));
                head.y = Math.max(50, Math.min(WORLD_HEIGHT - 50, head.y));

                // Update segments to follow with smooth interpolation
                // Use stronger following when boosting to prevent gaps
                const followStrength = this.boosting ? 0.6 : 0.3;
                
                for (let i = 1; i < this.segments.length; i++) {
                    const prev = this.segments[i - 1];
                    const curr = this.segments[i];
                    const dx = prev.x - curr.x;
                    const dy = prev.y - curr.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const targetDist = this.segmentRadius * 1.8;
                    
                    if (dist > 0) {
                        const ratio = targetDist / dist;
                        // Stronger interpolation when boosting to keep segments together
                        curr.x += (prev.x - dx * ratio - curr.x) * followStrength;
                        curr.y += (prev.y - dy * ratio - curr.y) * followStrength;
                    }
                }
            }

            updateAI() {
                const head = this.segments[0];
                
                // DEFENSIVE: Avoid walls first (highest priority) - ENHANCED
                const wallMargin = 300; // Increased from 200 - detect walls earlier
                const criticalWallMargin = 150; // Emergency zone
                let wallDanger = false;
                let criticalWallDanger = false;
                let wallTurnDirection = 0;
                
                // Check horizontal walls
                if (head.x < wallMargin) {
                    wallDanger = true;
                    if (head.x < criticalWallMargin) criticalWallDanger = true;
                    // Always turn right (away from left wall)
                    const angleToCenter = Math.atan2(WORLD_HEIGHT / 2 - head.y, WORLD_WIDTH / 2 - head.x);
                    let angleDiff = angleToCenter - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    wallTurnDirection = angleDiff > 0 ? 1 : -1;
                } else if (head.x > WORLD_WIDTH - wallMargin) {
                    wallDanger = true;
                    if (head.x > WORLD_WIDTH - criticalWallMargin) criticalWallDanger = true;
                    // Always turn left (away from right wall)
                    const angleToCenter = Math.atan2(WORLD_HEIGHT / 2 - head.y, WORLD_WIDTH / 2 - head.x);
                    let angleDiff = angleToCenter - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    wallTurnDirection = angleDiff > 0 ? 1 : -1;
                }
                
                // Check vertical walls
                if (head.y < wallMargin) {
                    wallDanger = true;
                    if (head.y < criticalWallMargin) criticalWallDanger = true;
                    const angleToCenter = Math.atan2(WORLD_HEIGHT / 2 - head.y, WORLD_WIDTH / 2 - head.x);
                    let angleDiff = angleToCenter - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    wallTurnDirection = angleDiff > 0 ? 1 : -1;
                } else if (head.y > WORLD_HEIGHT - wallMargin) {
                    wallDanger = true;
                    if (head.y > WORLD_HEIGHT - criticalWallMargin) criticalWallDanger = true;
                    const angleToCenter = Math.atan2(WORLD_HEIGHT / 2 - head.y, WORLD_WIDTH / 2 - head.x);
                    let angleDiff = angleToCenter - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    wallTurnDirection = angleDiff > 0 ? 1 : -1;
                }
                
                if (wallDanger) {
                    // Much stronger turning when near walls
                    const turnStrength = criticalWallDanger ? 0.5 : 0.35; // Increased from 0.3
                    this.angle += wallTurnDirection * turnStrength;
                    
                    // Always boost away from walls
                    if (this.boost > 10) {
                        this.boosting = true;
                    }
                    
                    // In critical zone, skip all other AI logic
                    if (criticalWallDanger) {
                        return; // Only focus on escaping wall
                    }
                }
                
                // Check ahead in current direction for self-collision (VERY AGGRESSIVE)
                const lookAheadDist = 200; // Increased from 150
                const checkPoints = 12; // Increased from 10
                let selfCollisionDetected = false;
                let closestDanger = Infinity;
                let dangerSide = 0;
                
                for (let step = 1; step <= checkPoints; step++) {
                    const checkDist = (lookAheadDist / checkPoints) * step;
                    const checkX = head.x + Math.cos(this.angle) * checkDist;
                    const checkY = head.y + Math.sin(this.angle) * checkDist;
                    
                    // Check every 3rd segment for performance, but larger radius
                    for (let i = 5; i < this.segments.length; i += 3) {
                        const segment = this.segments[i];
                        const dx = checkX - segment.x;
                        const dy = checkY - segment.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < this.segmentRadius * 8) { // Increased from 7
                            selfCollisionDetected = true;
                            
                            if (dist < closestDanger) {
                                closestDanger = dist;
                                
                                // Determine which way to turn (left or right)
                                const toSegmentAngle = Math.atan2(segment.y - head.y, segment.x - head.x);
                                let angleDiff = toSegmentAngle - this.angle;
                                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                                
                                dangerSide = angleDiff > 0 ? -1 : 1;
                            }
                        }
                    }
                }
                
                if (selfCollisionDetected) {
                    // Turn away EXTREMELY aggressively
                    this.angle += dangerSide * 0.6; // Increased from 0.5
                    if (this.boost > 15 && closestDanger < this.segmentRadius * 5) {
                        this.boosting = true; // Emergency boost
                    }
                    return; // Skip other AI logic when avoiding self
                }
                
                // DEFENSIVE: Check if we're about to hit the player's body
                if (player) {
                    const lookAheadDist = 80;
                    const checkPoints = 5;
                    
                    for (let step = 1; step <= checkPoints; step++) {
                        const checkDist = (lookAheadDist / checkPoints) * step;
                        const checkX = head.x + Math.cos(this.angle) * checkDist;
                        const checkY = head.y + Math.sin(this.angle) * checkDist;
                        
                        // Check if we're about to hit player's body
                        for (let i = 3; i < player.segments.length; i += 2) {
                            const playerSegment = player.segments[i];
                            const dx = checkX - playerSegment.x;
                            const dy = checkY - playerSegment.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < this.segmentRadius * 4) {
                                // DANGER! Player's body ahead, turn away!
                                const toPlayerAngle = Math.atan2(playerSegment.y - head.y, playerSegment.x - head.x);
                                let angleDiff = toPlayerAngle - this.angle;
                                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                                
                                // Turn away from player's body
                                if (angleDiff > 0) {
                                    this.angle -= 0.25; // Turn right to avoid
                                } else {
                                    this.angle += 0.25; // Turn left to avoid
                                }
                                
                                // Boost to escape if very close
                                if (dist < this.segmentRadius * 2 && this.boost > 20) {
                                    this.boosting = true;
                                }
                                
                                return; // Prioritize avoiding player
                            }
                        }
                    }
                    
                    // Also check proximity to player's body
                    for (let i = 5; i < player.segments.length; i += 3) {
                        const playerSegment = player.segments[i];
                        const dx = head.x - playerSegment.x;
                        const dy = head.y - playerSegment.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < this.segmentRadius * 6) {
                            // Too close to player's body, turn away
                            const awayAngle = Math.atan2(head.y - playerSegment.y, head.x - playerSegment.x);
                            let angleDiff = awayAngle - this.angle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            
                            this.angle += angleDiff * 0.1;
                        }
                    }
                }
                
                // EVASIVE: Dodge other AI snakes
                for (let otherSnake of snakes) {
                    if (otherSnake === this) continue;
                    
                    const otherHead = otherSnake.segments[0];
                    const dx = head.x - otherHead.x;
                    const dy = head.y - otherHead.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // If another AI is close, dodge away
                    if (dist < 150) {
                        const awayAngle = Math.atan2(dy, dx); // Angle away from other snake
                        let angleDiff = awayAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        // Turn away from the other snake
                        const turnStrength = Math.min(0.2, 30 / dist); // Stronger turn when closer
                        this.angle += angleDiff * turnStrength;
                        
                        // Boost to escape if very close
                        if (dist < 80 && this.boost > 20) {
                            this.boosting = true;
                        }
                    }
                    
                    // Also dodge other snake's bodies
                    for (let i = 5; i < otherSnake.segments.length; i += 5) {
                        const segment = otherSnake.segments[i];
                        const segDx = head.x - segment.x;
                        const segDy = head.y - segment.y;
                        const segDist = Math.sqrt(segDx * segDx + segDy * segDy);
                        
                        if (segDist < 100) {
                            const awayAngle = Math.atan2(segDy, segDx);
                            let angleDiff = awayAngle - this.angle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            
                            this.angle += angleDiff * 0.15;
                            
                            if (segDist < 50 && this.boost > 15) {
                                this.boosting = true;
                            }
                        }
                    }
                }
                
                // Also check if we're close to any part of our body (proximity check)
                for (let i = 20; i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    const dx = head.x - segment.x;
                    const dy = head.y - segment.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < this.segmentRadius * 8) {
                        // Getting too close to our own body, turn away
                        const toSegmentAngle = Math.atan2(dy, dx);
                        let angleDiff = toSegmentAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        // Turn in same direction as head is pointing relative to body
                        if (Math.abs(angleDiff) < Math.PI / 2) {
                            this.angle += angleDiff > 0 ? 0.15 : -0.15;
                        }
                    }
                }
                
                // Find nearest food or avoid other snakes
                let targetFood = null;
                let minDist = Infinity;
                
                // HARDPOINT/TOURNAMENT MODE: Go to the hardpoint zone
                if (isHardpointMode()) {
                    const dx = hardpoint.x - head.x;
                    const dy = hardpoint.y - head.y;
                    const distToHardpoint = Math.sqrt(dx * dx + dy * dy);
                    
                    // If not in hardpoint, go to it
                    if (distToHardpoint > hardpoint.radius) {
                        const targetAngle = Math.atan2(dy, dx);
                        let angleDiff = targetAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        this.angle += angleDiff * 0.1;
                        
                        // Boost towards hardpoint if far away
                        if (this.boost > 30 && distToHardpoint > 400) {
                            this.boosting = true;
                        } else if (this.boost < 20) {
                            this.boosting = false;
                        }
                        
                        return; // Focus on hardpoint
                    }
                    // If in hardpoint, stay near center
                    else {
                        const centerDx = hardpoint.x - head.x;
                        const centerDy = hardpoint.y - head.y;
                        const centerDist = Math.sqrt(centerDx * centerDx + centerDy * centerDy);
                        
                        if (centerDist > 50) {
                            const targetAngle = Math.atan2(centerDy, centerDx);
                            let angleDiff = targetAngle - this.angle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            this.angle += angleDiff * 0.05;
                        }
                        return;
                    }
                }
                
                // AGGRESSIVE: Try to attack nearby targets (player or other AI)
                // Difficulty modifiers
                let attackRange = 450;
                let turnSpeed = 0.12;
                let predictionDistance = 120;
                let minAttackSize = 8;
                
                if (this.difficulty === 'easy') {
                    attackRange = 300; // Short range
                    turnSpeed = 0.06; // Slow turning
                    predictionDistance = 50; // Poor prediction
                    minAttackSize = 20; // Only attack when large
                } else if (this.difficulty === 'hard') {
                    attackRange = 550; // Long range
                    turnSpeed = 0.18; // Fast turning
                    predictionDistance = 150; // Good prediction
                    minAttackSize = 5; // Attack almost always
                } else if (this.difficulty === 'insane') {
                    attackRange = 700; // Extreme range
                    turnSpeed = 0.25; // Lightning fast
                    predictionDistance = 200; // Perfect prediction
                    minAttackSize = 3; // Always aggressive
                }
                
                let targetSnake = null;
                let targetDist = Infinity;
                
                // Find closest target
                if (player && this.length > minAttackSize) {
                    const playerHead = player.segments[0];
                    const dx = playerHead.x - head.x;
                    const dy = playerHead.y - head.y;
                    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distToPlayer < attackRange) {
                        targetSnake = player;
                        targetDist = distToPlayer;
                    }
                }
                
                // Also check for nearby AI snakes to attack
                for (let otherSnake of snakes) {
                    if (otherSnake === this) continue;
                    // Attack all snakes smaller than us + similar size
                    if (otherSnake.length > this.length + 5) continue; // Only avoid much larger snakes
                    
                    const otherHead = otherSnake.segments[0];
                    const dx = otherHead.x - head.x;
                    const dy = otherHead.y - head.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // If this AI is closer than current target, attack it instead
                    if (dist < attackRange * 0.8 && dist < targetDist) {
                        targetSnake = otherSnake;
                        targetDist = dist;
                    }
                }
                
                // Attack the target if found
                if (targetSnake) {
                    const targetHead = targetSnake.segments[0];
                    
                    // Predict where target is going (better prediction)
                    const targetAngle = targetSnake.angle;
                    const predictX = targetHead.x + Math.cos(targetAngle) * predictionDistance;
                    const predictY = targetHead.y + Math.sin(targetAngle) * predictionDistance;
                    
                    // Try to intercept them
                    const interceptDx = predictX - head.x;
                    const interceptDy = predictY - head.y;
                    const angleToTarget = Math.atan2(interceptDy, interceptDx);
                    
                    let angleDiff = angleToTarget - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    this.angle += angleDiff * turnSpeed;
                    
                    // Boost when chasing (more aggressive)
                    const boostThreshold = this.difficulty === 'easy' ? 40 : (this.difficulty === 'insane' ? 15 : 25);
                    if (this.boost > boostThreshold && targetDist < 250) {
                        this.boosting = true;
                    } else if (this.boost < 15) {
                        this.boosting = false;
                    }
                    
                    return; // Focus on target, skip food seeking
                }

                for (let f of food) {
                    const dx = f.x - head.x;
                    const dy = f.y - head.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate angle to food
                    const angleToFood = Math.atan2(dy, dx);
                    let angleDiff = angleToFood - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Don't target food that's directly behind us (prevents circling)
                    if (Math.abs(angleDiff) > Math.PI * 0.75) {
                        continue; // Skip food behind us
                    }
                    
                    // Prioritize purple food - treat it as if it's closer
                    const effectiveDist = f.isPurple ? dist * 0.3 : dist;
                    
                    if (effectiveDist < minDist && dist < 600) {
                        minDist = effectiveDist;
                        targetFood = f;
                    }
                }

                if (targetFood) {
                    const dx = targetFood.x - head.x;
                    const dy = targetFood.y - head.y;
                    const targetAngle = Math.atan2(dy, dx);
                    
                    // Smooth angle transition to avoid jittering
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    this.angle += angleDiff * 0.05;
                } else {
                    // Smooth random movement
                    if (Math.random() < 0.01) {
                        this.targetAngle = this.angle + (Math.random() - 0.5) * 0.3;
                    }
                    
                    if (this.targetAngle !== undefined) {
                        let angleDiff = this.targetAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        this.angle += angleDiff * 0.05;
                    }
                }

                // Avoid edges smoothly
                const edgeBuffer = 300;
                
                if (head.x < edgeBuffer) {
                    const targetAngle = 0;
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    this.angle += angleDiff * 0.1;
                }
                if (head.x > WORLD_WIDTH - edgeBuffer) {
                    const targetAngle = Math.PI;
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    this.angle += angleDiff * 0.1;
                }
                if (head.y < edgeBuffer) {
                    const targetAngle = Math.PI / 2;
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    this.angle += angleDiff * 0.1;
                }
                if (head.y > WORLD_HEIGHT - edgeBuffer) {
                    const targetAngle = -Math.PI / 2;
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    this.angle += angleDiff * 0.1;
                }

                // Random boost with cooldown
                if (!this.lastBoostTime) this.lastBoostTime = 0;
                if (Math.random() < 0.003 && this.boost > 50 && Date.now() - this.lastBoostTime > 3000) {
                    this.boosting = true;
                    this.lastBoostTime = Date.now();
                } else if (this.boosting && this.boost < 20) {
                    this.boosting = false;
                }
            }

            grow(amount = 1) {
                for (let i = 0; i < amount; i++) {
                    const lastSegment = this.segments[this.segments.length - 1];
                    this.segments.push({
                        x: lastSegment.x,
                        y: lastSegment.y,
                        radius: this.segmentRadius
                    });
                }
                this.length = this.segments.length;
            }

            draw() {
                // Draw segments
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const segment = this.segments[i];
                    const ratio = i / this.segments.length;
                    
                    ctx.beginPath();
                    ctx.arc(
                        segment.x - camera.x,
                        segment.y - camera.y,
                        segment.radius,
                        0,
                        Math.PI * 2
                    );
                    
                    // Gradient color
                    const gradient = ctx.createRadialGradient(
                        segment.x - camera.x,
                        segment.y - camera.y,
                        0,
                        segment.x - camera.x,
                        segment.y - camera.y,
                        segment.radius
                    );
                    gradient.addColorStop(0, this.colors[0]);
                    gradient.addColorStop(1, this.colors[1]);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Outline
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Draw eyes on head
                const head = this.segments[0];
                const eyeOffset = this.segmentRadius * 0.5;
                const eyeSize = this.segmentRadius * 0.3;
                
                // Left eye
                ctx.beginPath();
                ctx.arc(
                    head.x - camera.x + Math.cos(this.angle - 0.3) * eyeOffset,
                    head.y - camera.y + Math.sin(this.angle - 0.3) * eyeOffset,
                    eyeSize,
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Right eye
                ctx.beginPath();
                ctx.arc(
                    head.x - camera.x + Math.cos(this.angle + 0.3) * eyeOffset,
                    head.y - camera.y + Math.sin(this.angle + 0.3) * eyeOffset,
                    eyeSize,
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw name
                ctx.font = 'bold 16px Righteous';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.fillText(this.name, head.x - camera.x, head.y - camera.y - this.segmentRadius - 15);
                ctx.shadowBlur = 0;
                
                // Draw spawn protection shield
                if (this.spawnProtection) {
                    const pulseAlpha = 0.3 + Math.sin(Date.now() / 100) * 0.2;
                    ctx.beginPath();
                    ctx.arc(
                        head.x - camera.x,
                        head.y - camera.y,
                        this.segmentRadius * 2,
                        0,
                        Math.PI * 2
                    );
                    ctx.strokeStyle = `rgba(0, 255, 255, ${pulseAlpha})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Inner shield glow
                    ctx.beginPath();
                    ctx.arc(
                        head.x - camera.x,
                        head.y - camera.y,
                        this.segmentRadius * 1.5,
                        0,
                        Math.PI * 2
                    );
                    ctx.fillStyle = `rgba(0, 255, 255, ${pulseAlpha * 0.2})`;
                    ctx.fill();
                }
            }

            checkCollision(otherSnake) {
                const head = this.segments[0];
                
                // Check collision with other snake's body segments (increased radius)
                for (let i = 5; i < otherSnake.segments.length; i++) {
                    const segment = otherSnake.segments[i];
                    const dx = head.x - segment.x;
                    const dy = head.y - segment.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Increased collision radius by 30% to prevent passing through
                    if (dist < (this.segmentRadius + segment.radius) * 1.3) {
                        return true;
                    }
                    
                    // Also check line between segments with increased radius
                    if (i < otherSnake.segments.length - 1) {
                        const nextSegment = otherSnake.segments[i + 1];
                        const lineToPointDist = distanceToLineSegment(
                            head.x, head.y,
                            segment.x, segment.y,
                            nextSegment.x, nextSegment.y
                        );
                        
                        if (lineToPointDist < (this.segmentRadius + segment.radius) * 1.3) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // Check if any part of our body collides with another snake's body
            checkBodyCollision(otherSnake) {
                // Check every 3rd segment for performance
                for (let i = 0; i < this.segments.length; i += 3) {
                    const mySegment = this.segments[i];
                    
                    for (let j = 0; j < otherSnake.segments.length; j += 3) {
                        const theirSegment = otherSnake.segments[j];
                        const dx = mySegment.x - theirSegment.x;
                        const dy = mySegment.y - theirSegment.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < mySegment.radius + theirSegment.radius) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }

        function initFood() {
            food = [];
            // Regular food
            for (let i = 0; i < FOOD_COUNT; i++) {
                food.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    radius: 5,
                    color: FOOD_COLORS[Math.floor(Math.random() * FOOD_COLORS.length)],
                    value: 1,
                    isPurple: false
                });
            }
            // Purple super food
            for (let i = 0; i < PURPLE_FOOD_COUNT; i++) {
                food.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    radius: 12,
                    color: PURPLE_FOOD_COLOR,
                    value: 30,
                    isPurple: true
                });
            }
        }

        function spawnFood(x, y, count = 5) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 50;
                food.push({
                    x: x + Math.cos(angle) * dist,
                    y: y + Math.sin(angle) * dist,
                    radius: 5,
                    color: FOOD_COLORS[Math.floor(Math.random() * FOOD_COLORS.length)],
                    value: 1,
                    isPurple: false
                });
            }
        }

        function initSnakes() {
            snakes = [];
            // Create AI snakes - 40 in Tournament, custom in Practice, 60 in Hardpoint, 29 in BR, 20 in other modes
            let aiCount = 20;
            if (gameMode === 'tournament') {
                aiCount = TOURNAMENT_AI_COUNT; // Always 40 in tournament
            } else if (gameMode === 'practice') {
                aiCount = botAmount; // Use custom amount
            } else if (gameMode === 'hardpoint') {
                aiCount = 60;
            } else if (gameMode === 'battleroyale') {
                aiCount = 29;
            }
            
            for (let i = 0; i < aiCount; i++) {
                const x = Math.random() * WORLD_WIDTH;
                const y = Math.random() * WORLD_HEIGHT;
                
                // In TDM, assign teams equally (6 blue teammates, 7 red enemies)
                let team = null;
                if (gameMode === 'tdm') {
                    team = i < 6 ? 'blue' : 'red';
                }
                
                const snake = new Snake(x, y, false, '', team);
                snake.grow(Math.floor(Math.random() * 20));
                
                // Set difficulty for practice mode
                if (gameMode === 'practice') {
                    snake.difficulty = botDifficulty;
                }
                
                snakes.push(snake);
            }
        }

        function startGame() {
            const nameInput = document.getElementById('playerName');
            const adminCodeInput = document.getElementById('adminCode');
            const gameModeSelect = document.getElementById('gameMode');
            let inputName = nameInput.value.trim();
            
            // Get selected game mode
            gameMode = gameModeSelect.value;
            console.log('Game Mode:', gameMode);
            
            // Get bot settings for practice mode
            if (gameMode === 'practice') {
                botAmount = parseInt(document.getElementById('botAmount').value);
                botDifficulty = document.getElementById('botDifficulty').value;
                console.log('Practice Mode - Bots:', botAmount, 'Difficulty:', botDifficulty);
            }
            
            // Check tournament play limit (once per month, unless admin)
            if (gameMode === 'tournament') {
                const tournamentData = JSON.parse(localStorage.getItem('tournamentProgress') || '{}');
                const currentMonth = new Date().getMonth() + '-' + new Date().getFullYear();
                
                // Check if admin code is correct first
                let isAdminBypass = false;
                if (adminCodeInput.value === ADMIN_CODE) {
                    isAdminBypass = true;
                }
                
                // Non-admins can only play once per month
                if (!isAdminBypass) {
                    if (tournamentData.month === currentMonth && tournamentData.hasPlayed) {
                        alert('‚ùå TOURNAMENT LOCKED\n\nYou can only play tournament ONCE per month!\n\nWait until next month or become ADMIN for unlimited plays.');
                        return; // Block game start
                    }
                }
            }
            
            // Log game start with session ID
            console.log('Game started - Session:', sessionID, 'Name:', inputName || 'Anonymous');
            const gameLog = JSON.parse(localStorage.getItem('snakeGameLog') || '[]');
            gameLog.push({
                sessionID: sessionID,
                name: inputName || 'Anonymous',
                mode: gameMode,
                timestamp: new Date().toISOString(),
                isAdmin: false
            });
            localStorage.setItem('snakeGameLog', JSON.stringify(gameLog));
            
            // Check admin code
            if (adminCodeInput.value) {
                // Secret cheat code: //win shows tournament victory screen
                if (adminCodeInput.value === '//win') {
                    // Show tournament victory with admin code
                    document.body.innerHTML = `
                        <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                            background: linear-gradient(135deg, #1a0033 0%, #330066 50%, #1a0033 100%);
                            display: flex; flex-direction: column; justify-content: center; align-items: center;
                            font-family: 'Bungee', 'Arial Black', sans-serif; z-index: 9999;">
                            <h1 style="font-size: 100px; color: #ffd700; text-shadow: 0 0 50px rgba(255, 215, 0, 0.8); margin-bottom: 20px;">VICTORY!</h1>
                            <p style="font-size: 36px; color: #40e0d0; margin-bottom: 10px;">TOURNAMENT CHAMPION! üèÜ</p>
                            <div style="margin-top: 30px; padding: 30px; background: rgba(255, 0, 128, 0.2); border: 3px solid #ff0080; border-radius: 20px; max-width: 600px;">
                                <p style="font-size: 28px; color: #ffd700; margin-bottom: 15px;">üéâ ADMIN CODE UNLOCKED! üéâ</p>
                                <div style="position: relative; margin: 20px 0;">
                                    <p id="adminCodeDisplay" style="font-size: 48px; color: #ff0080; font-weight: bold; letter-spacing: 5px;">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</p>
                                    <button id="toggleCodeBtn" onclick="toggleAdminCode()" style="margin-top: 10px; padding: 10px 30px; font-size: 16px; background: linear-gradient(45deg, #40e0d0, #00ffff); color: white; border: none; border-radius: 25px; cursor: pointer; font-family: 'Bungee', cursive;">SHOW CODE</button>
                                </div>
                                <p style="font-size: 16px; color: #40e0d0; margin-top: 15px;">Use this code in the lobby to become ADMIN!</p>
                                <div style="margin-top: 20px; padding: 15px; background: rgba(255, 0, 0, 0.3); border: 2px solid #ff0000; border-radius: 10px;">
                                    <p style="font-size: 14px; color: #ffff00; font-weight: bold;">‚ö†Ô∏è WARNING ‚ö†Ô∏è</p>
                                    <p style="font-size: 13px; color: #fff; margin-top: 8px;">DO NOT SHARE THIS CODE!</p>
                                    <p style="font-size: 12px; color: #fff; margin-top: 5px;">Sharing = Immediate ADMIN revocation</p>
                                </div>
                            </div>
                            <button onclick="location.reload()" style="margin-top: 40px; padding: 20px 60px; font-size: 24px; background: linear-gradient(45deg, #ff0080, #ff8c00); color: white; border: none; border-radius: 50px; cursor: pointer; font-family: 'Bungee', cursive;">RETURN TO LOBBY</button>
                        </div>
                    `;
                    
                    // Add toggle function after DOM is ready
                    setTimeout(() => {
                        window.toggleAdminCode = function() {
                            const display = document.getElementById('adminCodeDisplay');
                            const btn = document.getElementById('toggleCodeBtn');
                            
                            if (display.textContent === '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢') {
                                display.textContent = ADMIN_CODE_REVEAL;
                                btn.textContent = 'HIDE CODE';
                            } else {
                                display.textContent = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                                btn.textContent = 'SHOW CODE';
                            }
                        };
                    }, 0);
                    
                    return; // Stop game from starting
                } else if (adminCodeInput.value === ADMIN_CODE) {
                    isAdmin = true;
                    console.log('Admin mode activated');
                } else {
                    // WRONG CODE = INSTANT BAN
                    banUser();
                    return;
                }
            }
            
            // Don't mark as played yet - only mark when eliminated or win finals
            // Tournament progress is saved when advancing stages
            
            // Moderate the name (skip if admin)
            if (inputName && !isAdmin && !moderateName(inputName)) {
                // INAPPROPRIATE NAME = INSTANT BAN
                localStorage.setItem('snakeGameBanned', 'true');
                localStorage.setItem('snakeGameBanReason', 'Inappropriate name');
                document.body.innerHTML = `
                    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                                background: linear-gradient(135deg, #1a0033 0%, #330066 50%, #1a0033 100%);
                                display: flex; flex-direction: column; justify-content: center; align-items: center;
                                font-family: 'Bungee', cursive; color: #ff0055; animation: banFlash 0.5s;">
                        <h1 style="font-size: 100px; margin-bottom: 30px; text-shadow: 0 0 50px rgba(255, 0, 85, 0.8);">BANNED</h1>
                        <p style="font-size: 32px; color: #40e0d0;">You attempted to use an inappropriate name.</p>
                        <p style="font-size: 24px; color: #ff8c00; margin-top: 20px;">You are now permanently banned from this game.</p>
                        <p style="font-size: 18px; color: #888; margin-top: 40px;">Reason: Inappropriate content</p>
                        <input type="text" id="unbanInput" placeholder="Unban Code" 
                               style="margin-top: 40px; padding: 15px 30px; font-size: 20px; 
                                      background: rgba(0,0,0,0.7); color: #40e0d0; border: 3px solid #ff0080;
                                      border-radius: 30px; text-align: center; outline: none;" />
                        <button onclick="checkUnbanDirect()" 
                                style="margin-top: 20px; padding: 15px 40px; font-size: 20px;
                                       background: linear-gradient(45deg, #ff0080, #ff8c00); color: white;
                                       border: none; border-radius: 30px; cursor: pointer; font-family: 'Bungee', cursive;">
                            SUBMIT
                        </button>
                    </div>
                    <style>
                        @keyframes banFlash {
                            0%, 100% { background-color: rgba(255, 0, 0, 0.1); }
                            50% { background-color: rgba(255, 0, 0, 0.3); }
                        }
                    </style>
                `;
                
                // Add unban check function
                window.checkUnbanDirect = function() {
                    const input = document.getElementById('unbanInput');
                    if (input.value === 'UNBANALL') {
                        localStorage.removeItem('snakeGameBanned');
                        location.reload();
                    } else {
                        alert('Invalid unban code');
                    }
                };
                
                return;
            }
            
            playerName = inputName || 'Anonymous';
            if (isAdmin && playerName !== 'Anonymous') {
                playerName = '[ADMIN] ' + playerName;
            }
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('leaderboard').style.display = 'block';
            document.getElementById('boostIndicator').style.display = 'block';
            document.getElementById('controlsHint').style.display = 'block';
            document.getElementById('pauseButton').style.display = 'block';
            document.getElementById('weaponsBar').style.display = 'flex';
            
            // Show joystick and boost button on all devices
            document.getElementById('joystick').style.display = 'block';
            document.getElementById('mobileBoost').style.display = 'flex';
            document.getElementById('mobileVenom').style.display = 'flex';
            
            // Update controls hint for admin
            if (isAdmin) {
                document.getElementById('controlsHint').innerHTML = 'Move mouse to control ‚Ä¢ Click to boost ‚Ä¢ SPACE/E to fire ‚Ä¢ ESC to pause<br><span style="color: #ff0080;">ADMIN: G=Grow | T=Teleport | K=Kill | I=Immunity</span>';
            }
            
            gameStarted = true;
            
            // Create player snake
            player = new Snake(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, true, playerName, gameMode === 'tdm' ? 'blue' : null);
            
            // Admin perks
            if (isAdmin) {
                player.grow(50); // Start with extra length
                player.maxBoost = 200; // Double boost capacity
                player.boost = 200;
            }
            
            initFood();
            initSnakes();
            
            // Initialize storm for Battle Royale
            if (gameMode === 'battleroyale') {
                storm.x = WORLD_WIDTH / 2;
                storm.y = WORLD_HEIGHT / 2;
                storm.currentRadius = WORLD_WIDTH * 0.8; // Start at 80%
                storm.targetRadius = WORLD_WIDTH * 0.72; // Stage 1 target (92% of 80%)
                storm.shrinkStage = 1; // Start at stage 1
                storm.pauseUntil = 0; // No pause - shrink immediately
                storm.isMoving = false;
                storm.targetX = WORLD_WIDTH / 2;
                storm.targetY = WORLD_HEIGHT / 2;
                storm.damageTimer = 0;
            }
            
            gameLoop();
        }

        function shootVenom() {
            if (!player || gameOver || isPaused) return;
            
            // Admin can rapid fire (no cooldown)
            if (!isAdmin && venomCooldown > 0) return;
            
            const head = player.segments[0];
            venomShots.push({
                x: head.x,
                y: head.y,
                angle: player.angle,
                speed: 8,
                radius: 6,
                lifetime: 180 // 3 seconds at 60fps
            });
            
            // Only set cooldown for non-admins
            if (!isAdmin) {
                venomCooldown = VENOM_COOLDOWN_TIME;
            }
        }
        
        function fireWeapon() {
            if (!player || gameOver || isPaused) return;
            
            switch(currentWeapon) {
                case 1: shootVenom(); break;
                case 2: shootLaser(); break;
                case 3: shootExplosive(); break;
                case 4: dropMine(); break;
                case 5: throwHook(); break;
                case 6: dash(); break;
                case 7: activatePoisonTrail(); break;
            }
        }
        
        function shootLaser() {
            if (!isAdmin && laserCooldown > 0) return;
            
            const head = player.segments[0];
            laserBeams.push({
                x: head.x,
                y: head.y,
                angle: player.angle,
                length: 1000, // Very long beam
                width: 3,
                lifetime: 15 // 0.25 seconds - instant cut
            });
            
            if (!isAdmin) laserCooldown = LASER_COOLDOWN_TIME;
        }
        
        function shootExplosive() {
            if (!isAdmin && explosiveCooldown > 0) return;
            
            const head = player.segments[0];
            explosiveShots.push({
                x: head.x,
                y: head.y,
                angle: player.angle,
                speed: 6,
                radius: 8,
                lifetime: 120,
                exploded: false
            });
            
            if (!isAdmin) explosiveCooldown = EXPLOSIVE_COOLDOWN_TIME;
        }
        
        function dropMine() {
            if (!isAdmin && mineCooldown > 0) return;
            
            const head = player.segments[0];
            mines.push({
                x: head.x,
                y: head.y,
                radius: 15,
                armed: false, // Arms after 1 second
                armTime: 60
            });
            
            if (!isAdmin) mineCooldown = MINE_COOLDOWN_TIME;
        }
        
        function throwHook() {
            if (!isAdmin && hookCooldown > 0) return;
            
            const head = player.segments[0];
            hooks.push({
                x: head.x,
                y: head.y,
                angle: player.angle,
                speed: 10,
                radius: 8,
                lifetime: 120,
                returning: false,
                target: null
            });
            
            if (!isAdmin) hookCooldown = HOOK_COOLDOWN_TIME;
        }
        
        function dash() {
            if (!isAdmin && dashCooldown > 0) return;
            if (!player) return;
            
            const head = player.segments[0];
            const dashDistance = 200;
            
            // Teleport forward
            head.x += Math.cos(player.angle) * dashDistance;
            head.y += Math.sin(player.angle) * dashDistance;
            
            // Keep in bounds
            head.x = Math.max(50, Math.min(WORLD_WIDTH - 50, head.x));
            head.y = Math.max(50, Math.min(WORLD_HEIGHT - 50, head.y));
            
            if (!isAdmin) dashCooldown = DASH_COOLDOWN_TIME;
        }
        
        function activatePoisonTrail() {
            if (!isAdmin && poisonTrailCooldown > 0) return;
            
            poisonTrailActive = true;
            poisonTrailSegments = [];
            
            // Trail lasts 5 seconds
            setTimeout(() => {
                poisonTrailActive = false;
            }, 5000);
            
            if (!isAdmin) poisonTrailCooldown = POISON_TRAIL_COOLDOWN_TIME;
        }

        function togglePause() {
            if (gameOver) return;
            
            isPaused = !isPaused;
            const pauseButton = document.getElementById('pauseButton');
            const pauseOverlay = document.getElementById('pauseOverlay');
            
            if (isPaused) {
                pauseButton.textContent = 'RESUME';
                pauseOverlay.style.display = 'flex';
            } else {
                pauseButton.textContent = 'PAUSE';
                pauseOverlay.style.display = 'none';
                gameLoop();
            }
        }

        function goHome() {
            if (confirm('Are you sure you want to return to the home screen? Your progress will be lost.')) {
                location.reload();
            }
        }

        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let lastMouseUpdate = 0;

        canvas.addEventListener('mousemove', (e) => {
            // High precision mouse tracking
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            lastMouseUpdate = performance.now();
        });

        canvas.addEventListener('mousedown', () => {
            if (player && !gameOver && !isPaused) {
                player.boosting = true;
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (player) {
                player.boosting = false;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && player && !gameOver && !isPaused) {
                e.preventDefault();
                fireWeapon(); // Fire weapon on space
            }
            if (e.code === 'Escape') {
                e.preventDefault();
                togglePause();
            }
            
            // Weapon switching (1-7 keys)
            if (player && !gameOver && !isPaused) {
                if (e.code === 'Digit1') currentWeapon = 1; // Venom
                if (e.code === 'Digit2') currentWeapon = 2; // Laser
                if (e.code === 'Digit3') currentWeapon = 3; // Explosive
                if (e.code === 'Digit4') currentWeapon = 4; // Mine
                if (e.code === 'Digit5') currentWeapon = 5; // Hook
                if (e.code === 'Digit6') currentWeapon = 6; // Dash
                if (e.code === 'Digit7') currentWeapon = 7; // Poison Trail
            }
            
            // Fire weapon with E key
            if (e.code === 'KeyE' && player && !gameOver && !isPaused) {
                fireWeapon();
            }
            
            // Admin cheats
            if (isAdmin && player && !gameOver) {
                if (e.code === 'KeyG') {
                    // Grow instantly
                    player.grow(10);
                    console.log('Admin: Grew by 10');
                }
                if (e.code === 'KeyT') {
                    // Teleport to mouse position
                    const head = player.segments[0];
                    head.x = mouseX + camera.x;
                    head.y = mouseY + camera.y;
                    console.log('Admin: Teleported');
                }
                if (e.code === 'KeyK') {
                    // Kill nearest snake
                    if (snakes.length > 0) {
                        const nearest = snakes[0];
                        spawnFood(nearest.segments[0].x, nearest.segments[0].y, nearest.length);
                        snakes.splice(0, 1);
                        
                        // Don't respawn in hardpoint/BR
                        if (shouldRespawn()) {
                            const x = Math.random() * WORLD_WIDTH;
                            const y = Math.random() * WORLD_HEIGHT;
                            const newSnake = new Snake(x, y, false);
                            snakes.push(newSnake);
                        }
                        console.log('Admin: Killed nearest snake');
                    }
                }
                if (e.code === 'KeyI') {
                    // Toggle immunity
                    adminImmune = !adminImmune;
                    console.log('Admin: Immunity ' + (adminImmune ? 'ON' : 'OFF'));
                    alert('Immunity: ' + (adminImmune ? 'ON' : 'OFF'));
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            // Space fires weapons, no keyup needed
        });

        function updateCamera() {
            if (player) {
                camera.x = player.segments[0].x - canvas.width / 2;
                camera.y = player.segments[0].y - canvas.height / 2;
                
                // Add padding to keep camera scrolling near edges (prevents corner wrapping)
                const edgePadding = 300; // Pixels of padding from edge
                const minX = -edgePadding;
                const maxX = WORLD_WIDTH - canvas.width + edgePadding;
                const minY = -edgePadding;
                const maxY = WORLD_HEIGHT - canvas.height + edgePadding;
                
                camera.x = Math.max(minX, Math.min(maxX, camera.x));
                camera.y = Math.max(minY, Math.min(maxY, camera.y));
            }
        }

        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            // Calculate distance from point (px, py) to line segment (x1, y1) to (x2, y2)
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSquared = dx * dx + dy * dy;
            
            if (lengthSquared === 0) {
                // Line segment is actually a point
                const distX = px - x1;
                const distY = py - y1;
                return Math.sqrt(distX * distX + distY * distY);
            }
            
            // Find projection of point onto line segment
            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t));
            
            // Find closest point on line segment
            const closestX = x1 + t * dx;
            const closestY = y1 + t * dy;
            
            // Calculate distance
            const distX = px - closestX;
            const distY = py - closestY;
            return Math.sqrt(distX * distX + distY * distY);
        }

        function checkFoodCollision(snake) {
            const head = snake.segments[0];
            
            for (let i = food.length - 1; i >= 0; i--) {
                const f = food[i];
                const dx = head.x - f.x;
                const dy = head.y - f.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < snake.segmentRadius + f.radius) {
                    const wasPurple = f.isPurple;
                    food.splice(i, 1);
                    snake.grow(f.value);
                    
                    // Spawn new food to replace
                    if (wasPurple) {
                        // Respawn purple food at random location
                        food.push({
                            x: Math.random() * WORLD_WIDTH,
                            y: Math.random() * WORLD_HEIGHT,
                            radius: 12,
                            color: PURPLE_FOOD_COLOR,
                            value: 30,
                            isPurple: true
                        });
                    } else {
                        // Spawn regular food
                        food.push({
                            x: Math.random() * WORLD_WIDTH,
                            y: Math.random() * WORLD_HEIGHT,
                            radius: 5,
                            color: FOOD_COLORS[Math.floor(Math.random() * FOOD_COLORS.length)],
                            value: 1,
                            isPurple: false
                        });
                    }
                }
            }
        }

        function endGame() {
            gameOver = true;
            
            const allSnakes = [player, ...snakes].sort((a, b) => b.length - a.length);
            const playerRank = allSnakes.indexOf(player) + 1;
            
            let tournamentResult = '';
            
            // Check tournament placement
            if (gameMode === 'tournament') {
                const tournamentData = JSON.parse(localStorage.getItem('tournamentProgress') || '{}');
                let qualified = false;
                let message = '';
                
                if (tournamentStage === 'qualifier' && playerRank <= 10) {
                    qualified = true;
                    tournamentData.stage = 'quarters';
                    message = '<div style="color: #00ff00; font-size: 20px; margin-top: 15px;">‚úÖ QUALIFIED FOR QUARTER-FINALS!</div>';
                } else if (tournamentStage === 'quarters' && playerRank <= 10) {
                    qualified = true;
                    tournamentData.stage = 'semis';
                    message = '<div style="color: #00ff00; font-size: 20px; margin-top: 15px;">‚úÖ ADVANCED TO SEMI-FINALS!</div>';
                } else if (tournamentStage === 'semis' && playerRank <= 7) {
                    qualified = true;
                    tournamentData.stage = 'finals';
                    message = '<div style="color: #00ff00; font-size: 20px; margin-top: 15px;">‚úÖ ADVANCED TO FINALS!</div>';
                } else if (tournamentStage === 'finals' && playerRank === 1) {
                    qualified = true;
                    tournamentData.stage = 'qualifier'; // Reset
                    // Keep the month so hasPlayed persists
                    const currentMonth = new Date().getMonth() + '-' + new Date().getFullYear();
                    tournamentData.month = currentMonth;
                    tournamentData.hasPlayed = true; // Lock tournament for this month
                    message = `
                        <div style="color: #ffd700; font-size: 24px; margin-top: 15px; padding: 20px; background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd700; border-radius: 10px;">
                            üèÜ TOURNAMENT CHAMPION! üèÜ<br>
                            <div style="margin-top: 15px;">
                                <div id="gameOverAdminCode" style="font-size: 32px; color: #ff0080;">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</div>
                                <button id="gameOverToggleBtn" onclick="toggleGameOverCode()" style="margin-top: 10px; padding: 8px 20px; font-size: 14px; background: linear-gradient(45deg, #40e0d0, #00ffff); color: white; border: none; border-radius: 20px; cursor: pointer; font-family: 'Bungee', cursive;">SHOW CODE</button>
                            </div>
                            <div style="margin-top: 15px; padding: 10px; background: rgba(255, 0, 0, 0.3); border: 2px solid #ff0000; border-radius: 8px;">
                                <div style="font-size: 12px; color: #ffff00; font-weight: bold;">‚ö†Ô∏è WARNING ‚ö†Ô∏è</div>
                                <div style="font-size: 11px; color: #fff; margin-top: 5px;">DO NOT SHARE THIS CODE!</div>
                                <div style="font-size: 10px; color: #fff; margin-top: 3px;">Sharing = ADMIN revoked</div>
                            </div>
                        </div>
                    `;
                } else {
                    // Failed to qualify - MARK AS PLAYED FOR THIS MONTH
                    message = '<div style="color: #ff0000; font-size: 18px; margin-top: 15px;">‚ùå ELIMINATED - Try again next month</div>';
                    tournamentData.stage = 'qualifier';
                    // Keep the month so hasPlayed persists
                    const currentMonth = new Date().getMonth() + '-' + new Date().getFullYear();
                    tournamentData.month = currentMonth;
                    tournamentData.hasPlayed = true; // Lock tournament for this month
                }
                
                if (qualified) {
                    // Don't mark as played yet - they can continue
                    localStorage.setItem('tournamentProgress', JSON.stringify(tournamentData));
                } else {
                    // Mark as played - they're eliminated
                    localStorage.setItem('tournamentProgress', JSON.stringify(tournamentData));
                }
                
                tournamentResult = message;
            }
            
            document.getElementById('finalStats').innerHTML = `
                Final Length: ${player.length}<br>
                Final Rank: #${playerRank} / ${allSnakes.length}
                ${tournamentResult}
            `;
            
            // Remove player and hide UI
            player = null;
            document.getElementById('hud').style.display = 'none';
            document.getElementById('boostIndicator').style.display = 'none';
            document.getElementById('joystick').style.display = 'none';
            document.getElementById('mobileBoost').style.display = 'none';
            document.getElementById('mobileVenom').style.display = 'none';
            
            const gameOverScreen = document.getElementById('gameOver');
            gameOverScreen.style.display = 'flex';
            gameOverScreen.style.zIndex = '9999';
            
            // Prevent any code from hiding the game over screen
            Object.defineProperty(gameOverScreen.style, 'display', {
                value: 'flex',
                writable: false,
                configurable: false
            });
        }
        
        function victory() {
            gameOver = true;
            player = null;
            
            let victoryMessage = '';
            let extraInfo = '';
            
            // Handle tournament victory
            if (gameMode === 'tournament') {
                const tournamentData = JSON.parse(localStorage.getItem('tournamentProgress') || '{}');
                
                if (tournamentStage === 'qualifier') {
                    tournamentData.stage = 'quarters';
                    victoryMessage = 'QUALIFIED FOR QUARTER-FINALS!';
                    extraInfo = '<p style="font-size: 20px; color: #ffd700; margin-top: 20px;">Play again to continue tournament</p>';
                } else if (tournamentStage === 'quarters') {
                    tournamentData.stage = 'semis';
                    victoryMessage = 'ADVANCED TO SEMI-FINALS!';
                    extraInfo = '<p style="font-size: 20px; color: #ffd700; margin-top: 20px;">Play again to continue tournament</p>';
                } else if (tournamentStage === 'semis') {
                    tournamentData.stage = 'finals';
                    victoryMessage = 'ADVANCED TO FINALS!';
                    extraInfo = '<p style="font-size: 20px; color: #ffd700; margin-top: 20px;">Get 1ST PLACE for the ADMIN CODE!</p>';
                } else if (tournamentStage === 'finals') {
                    // TOURNAMENT WINNER - Show admin code and mark as played
                    tournamentData.stage = 'qualifier'; // Reset for next month
                    // Keep the month so hasPlayed persists
                    const currentMonth = new Date().getMonth() + '-' + new Date().getFullYear();
                    tournamentData.month = currentMonth;
                    tournamentData.hasPlayed = true; // Lock tournament for this month
                    victoryMessage = 'TOURNAMENT CHAMPION! üèÜ';
                    extraInfo = `
                        <div style="margin-top: 30px; padding: 30px; background: rgba(255, 0, 128, 0.2); border: 3px solid #ff0080; border-radius: 20px;">
                            <p style="font-size: 28px; color: #ffd700; margin-bottom: 15px;">üéâ ADMIN CODE UNLOCKED! üéâ</p>
                            <div style="position: relative; margin: 20px 0;">
                                <p id="victoryAdminCode" style="font-size: 48px; color: #ff0080; font-weight: bold; letter-spacing: 5px;">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</p>
                                <button id="victoryToggleBtn" onclick="toggleVictoryCode()" style="margin-top: 10px; padding: 10px 30px; font-size: 16px; background: linear-gradient(45deg, #40e0d0, #00ffff); color: white; border: none; border-radius: 25px; cursor: pointer; font-family: 'Bungee', cursive;">SHOW CODE</button>
                            </div>
                            <p style="font-size: 16px; color: #40e0d0; margin-top: 15px;">Use this code in the lobby to become ADMIN!</p>
                            <div style="margin-top: 20px; padding: 15px; background: rgba(255, 0, 0, 0.3); border: 2px solid #ff0000; border-radius: 10px;">
                                <p style="font-size: 14px; color: #ffff00; font-weight: bold;">‚ö†Ô∏è WARNING ‚ö†Ô∏è</p>
                                <p style="font-size: 13px; color: #fff; margin-top: 8px;">DO NOT SHARE THIS CODE!</p>
                                <p style="font-size: 12px; color: #fff; margin-top: 5px;">Sharing = Immediate ADMIN revocation</p>
                            </div>
                        </div>
                    `;
                }
                
                localStorage.setItem('tournamentProgress', JSON.stringify(tournamentData));
            } else {
                victoryMessage = 'YOU ARE THE CHAMPION!';
            }
            
            // Show victory screen
            document.body.innerHTML += `
                <div id="victoryScreen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: linear-gradient(135deg, #1a0033 0%, #330066 50%, #1a0033 100%);
                    display: flex; flex-direction: column; justify-content: center; align-items: center;
                    font-family: 'Bungee', 'Arial Black', sans-serif; z-index: 3000;
                    animation: victoryFade 0.5s;">
                    <h1 style="font-size: 100px; color: #ffd700; text-shadow: 0 0 50px rgba(255, 215, 0, 0.8); margin-bottom: 20px;">VICTORY!</h1>
                    <p style="font-size: 36px; color: #40e0d0; margin-bottom: 10px;">${victoryMessage}</p>
                    <p style="font-size: 24px; color: #ff0080;">Final Score: ${gameMode === 'tournament' || gameMode === 'hardpoint' ? Math.floor(hardpointScore.player) : player ? player.length : 0}</p>
                    ${extraInfo}
                    <p style="font-size: 18px; color: #888; margin-top: 20px;">Returning to lobby...</p>
                </div>
                <style>
                    @keyframes victoryFade {
                        from { opacity: 0; transform: scale(0.8); }
                        to { opacity: 1; transform: scale(1); }
                    }
                </style>
            `;
            
            // Return to lobby after 5 seconds (10 seconds if showing admin code)
            const delay = (gameMode === 'tournament' && tournamentStage === 'finals') ? 10000 : 5000;
            setTimeout(() => {
                location.reload();
            }, 5000);
        }
        
        // Toggle admin code visibility in victory screen
        function toggleVictoryCode() {
            const display = document.getElementById('victoryAdminCode');
            const btn = document.getElementById('victoryToggleBtn');
            
            if (display.textContent === '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢') {
                display.textContent = ADMIN_CODE_REVEAL;
                btn.textContent = 'HIDE CODE';
            } else {
                display.textContent = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                btn.textContent = 'SHOW CODE';
            }
        }
        
        // Toggle admin code visibility in game over screen
        function toggleGameOverCode() {
            const display = document.getElementById('gameOverAdminCode');
            const btn = document.getElementById('gameOverToggleBtn');
            
            if (display.textContent === '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢') {
                display.textContent = ADMIN_CODE_REVEAL;
                btn.textContent = 'HIDE CODE';
            } else {
                display.textContent = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                btn.textContent = 'SHOW CODE';
            }
        }

        function updateLeaderboard() {
            const allSnakes = [player, ...snakes].sort((a, b) => b.length - a.length);
            const top5 = allSnakes.slice(0, 5);
            
            let html = '';
            top5.forEach((snake, index) => {
                const isPlayer = snake === player;
                html += `<div class="leaderboard-item ${isPlayer ? 'player' : ''}">
                    ${index + 1}. ${snake.name} - ${snake.length}
                </div>`;
            });
            
            document.getElementById('leaderboardList').innerHTML = html;
            
            const playerRank = allSnakes.indexOf(player) + 1;
            document.getElementById('rank').textContent = `#${playerRank}`;
        }

        function drawHardpoint() {
            if (gameMode !== 'hardpoint') return;
            
            // Update glow animation
            hardpoint.glowPhase += 0.05;
            
            // Draw hardpoint zone
            const screenX = hardpoint.x - camera.x;
            const screenY = hardpoint.y - camera.y;
            
            // Outer glow
            const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, hardpoint.radius);
            gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
            gradient.addColorStop(0.7, 'rgba(255, 215, 0, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Inner circle with pulsing effect
            const pulseSize = Math.sin(hardpoint.glowPhase) * 10;
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(screenX, screenY, hardpoint.radius + pulseSize, 0, Math.PI * 2);
            ctx.stroke();
            
            // Center indicator
            ctx.fillStyle = '#ffd700';
            ctx.font = '30px Bungee, Arial Black, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('HARDPOINT', screenX, screenY - 10);
            
            // Score display
            ctx.font = '20px Righteous, Arial Black, sans-serif';
            ctx.fillStyle = '#40e0d0';
            ctx.fillText(`YOU: ${hardpointScore.player}`, screenX, screenY + 20);
            ctx.fillStyle = '#ff0080';
            ctx.fillText(`AI: ${hardpointScore.ai}`, screenX, screenY + 45);
            
            // Move hardpoint after 30 seconds
            if (Date.now() > hardpoint.nextMoveTime) {
                hardpoint.x = Math.random() * (WORLD_WIDTH - 400) + 200;
                hardpoint.y = Math.random() * (WORLD_HEIGHT - 400) + 200;
                hardpoint.nextMoveTime = Date.now() + 30000;
            }
            
            // Draw direction pointer if hardpoint is off-screen
            if (player) {
                const screenX = hardpoint.x - camera.x;
                const screenY = hardpoint.y - camera.y;
                
                // Check if hardpoint is off-screen
                if (screenX < 0 || screenX > canvas.width || screenY < 0 || screenY > canvas.height) {
                    // Calculate angle from screen center to hardpoint
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const angle = Math.atan2(screenY - centerY, screenX - centerX);
                    
                    // Position pointer on edge of screen
                    const margin = 50;
                    let pointerX, pointerY;
                    
                    // Calculate intersection with screen edges
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    if (Math.abs(cos) > Math.abs(sin)) {
                        // Hits left or right edge
                        if (cos > 0) {
                            pointerX = canvas.width - margin;
                            pointerY = centerY + (canvas.width - margin - centerX) * Math.tan(angle);
                        } else {
                            pointerX = margin;
                            pointerY = centerY + (margin - centerX) * Math.tan(angle);
                        }
                    } else {
                        // Hits top or bottom edge
                        if (sin > 0) {
                            pointerY = canvas.height - margin;
                            pointerX = centerX + (canvas.height - margin - centerY) / Math.tan(angle);
                        } else {
                            pointerY = margin;
                            pointerX = centerX + (margin - centerY) / Math.tan(angle);
                        }
                    }
                    
                    // Draw arrow pointer
                    ctx.save();
                    ctx.translate(pointerX, pointerY);
                    ctx.rotate(angle);
                    
                    // Arrow shape
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(20, 0);
                    ctx.lineTo(-10, -15);
                    ctx.lineTo(-10, 15);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Arrow outline
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Distance text
                    const dist = Math.sqrt(Math.pow(hardpoint.x - (camera.x + centerX), 2) + Math.pow(hardpoint.y - (camera.y + centerY), 2));
                    ctx.rotate(-angle);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '14px Bungee, Arial Black, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(Math.floor(dist) + 'm', 0, -25);
                    
                    ctx.restore();
                }
            }
        }
        
        function updateStorm() {
            if (shouldRespawn()) return;
            
            const now = Date.now();
            
            // Shrink towards target
            if (storm.currentRadius > storm.targetRadius + 5) {
                storm.currentRadius -= 2;
            } else if (storm.currentRadius > storm.targetRadius) {
                storm.currentRadius = storm.targetRadius; // Snap to target
                console.log('Storm reached target radius:', storm.targetRadius);
            }
            
            // Check if we've reached target
            if (storm.currentRadius === storm.targetRadius && storm.shrinkStage < storm.maxStages) {
                // If pauseUntil is 0, we just finished shrinking - set pause
                if (storm.pauseUntil === 0) {
                    storm.pauseUntil = now + 20000;
                    console.log('Storm pausing for 20 seconds at stage', storm.shrinkStage);
                }
                // If pause time is set and has expired, advance to next stage
                else if (storm.pauseUntil > 0 && now >= storm.pauseUntil) {
                    storm.shrinkStage++;
                    console.log('Storm advancing to stage', storm.shrinkStage);
                    
                    // Calculate next target based on CURRENT radius
                    if (storm.shrinkStage <= 8) {
                        // Stages 1-8: Shrink by 8% of WORLD_WIDTH each time
                        storm.targetRadius = WORLD_WIDTH * (1 - (storm.shrinkStage * 0.08));
                    } else if (storm.shrinkStage < 12) {
                        // Stages 9-11: Shrink to 70% of current size
                        storm.targetRadius = storm.currentRadius * 0.7;
                        // Also move location
                        const angle = Math.random() * Math.PI * 2;
                        const distance = storm.currentRadius * 0.3;
                        storm.targetX = storm.x + Math.cos(angle) * distance;
                        storm.targetY = storm.y + Math.sin(angle) * distance;
                        storm.isMoving = true;
                    } else {
                        // Stage 12: Completely closed
                        storm.targetRadius = 0;
                    }
                    
                    console.log('New target radius:', storm.targetRadius, 'current:', storm.currentRadius);
                    
                    // Clear pause so shrinking can start next frame
                    storm.pauseUntil = 0;
                }
            }
            
            // Move storm center (stages 9-12)
            if (storm.isMoving) {
                const dx = storm.targetX - storm.x;
                const dy = storm.targetY - storm.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    storm.x += (dx / dist) * 3;
                    storm.y += (dy / dist) * 3;
                } else {
                    storm.isMoving = false;
                }
            }
        }
        
        function drawStorm() {
            if (shouldRespawn()) return;
            
            // Draw safe zone (white circle)
            const safeX = storm.x - camera.x;
            const safeY = storm.y - camera.y;
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.arc(safeX, safeY, storm.currentRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw storm (purple fog covering everything outside)
            ctx.save();
            ctx.fillStyle = 'rgba(138, 43, 226, 0.4)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Cut out safe zone
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(safeX, safeY, storm.currentRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Storm info
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px Bungee, Arial Black, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Stage: ${storm.shrinkStage}/${storm.maxStages}`, 20, canvas.height - 60);
            
            const timeLeft = Math.max(0, Math.floor((storm.pauseUntil - Date.now()) / 1000));
            if (timeLeft > 0) {
                ctx.fillText(`Next: ${timeLeft}s`, 20, canvas.height - 30);
            } else {
                ctx.fillText('Shrinking...', 20, canvas.height - 30);
            }
        }
        
        function checkStormDamage(snake) {
            if (shouldRespawn()) return false;
            
            const head = snake.segments[0];
            const dx = head.x - storm.x;
            const dy = head.y - storm.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Outside safe zone = instant death
            if (dist > storm.currentRadius) {
                return true;
            }
            
            return false;
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 0, 128, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const startX = Math.floor(camera.x / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize;
            
            for (let x = startX; x < camera.x + canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x - camera.x, 0);
                ctx.lineTo(x - camera.x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < camera.y + canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y - camera.y);
                ctx.lineTo(canvas.width, y - camera.y);
                ctx.stroke();
            }
        }

        function gameLoop() {
            if (!gameStarted || gameOver || isPaused) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update storm
            updateStorm();
            
            // Draw grid
            drawGrid();
            
            // Draw storm
            drawStorm();
            
            // Draw hardpoint zone
            drawHardpoint();
            
            // Check if player is in hardpoint (score points with escalating multiplier)
            if (isHardpointMode() && player) {
                const dx = player.segments[0].x - hardpoint.x;
                const dy = player.segments[0].y - hardpoint.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < hardpoint.radius) {
                    // Player is in zone
                    playerInZone = true;
                    playerOutsideTimer = 0; // Reset outside timer
                    playerZoneTime++; // Track time in zone
                    
                    // Increase multiplier every 1 second (60 frames)
                    if (playerZoneTime % 60 === 0) {
                        playerMultiplier *= 1.5;
                    }
                    
                    // Score with current multiplier (base 2 points * multiplier)
                    hardpointScore.player += 2 * playerMultiplier;
                    
                } else {
                    // Player is outside zone
                    playerInZone = false;
                    playerOutsideTimer++;
                    
                    // Reset multiplier after 3 seconds outside (180 frames at 60fps)
                    if (playerOutsideTimer >= 180) {
                        playerMultiplier = 1;
                        playerZoneTime = 0;
                    }
                }
            }
            
            // Update venom cooldown
            if (venomCooldown > 0) {
                venomCooldown--;
            }
            
            // Update and draw venom shots
            for (let i = venomShots.length - 1; i >= 0; i--) {
                const venom = venomShots[i];
                
                // Move venom
                venom.x += Math.cos(venom.angle) * venom.speed;
                venom.y += Math.sin(venom.angle) * venom.speed;
                venom.lifetime--;
                
                // Remove if expired
                if (venom.lifetime <= 0) {
                    venomShots.splice(i, 1);
                    continue;
                }
                
                // Check collision with AI snakes
                for (let j = snakes.length - 1; j >= 0; j--) {
                    const snake = snakes[j];
                    let hit = false;
                    
                    // Check collision with each segment
                    for (let s = 0; s < snake.segments.length; s++) {
                        const segment = snake.segments[s];
                        const dx = venom.x - segment.x;
                        const dy = venom.y - segment.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < venom.radius + snake.segmentRadius) {
                            // Hit first 3 segments = kill snake
                            if (s < 3) {
                                spawnFood(snake.segments[0].x, snake.segments[0].y, snake.length);
                                snakes.splice(j, 1);
                                
                                // Spawn new snake
                                if (shouldRespawn()) {
                                    const x = Math.random() * WORLD_WIDTH;
                                    const y = Math.random() * WORLD_HEIGHT;
                                    const newSnake = new Snake(x, y, false, '', gameMode === 'tdm' ? snake.team : null);
                                    snakes.push(newSnake);
                                }
                            }
                            // Hit body (segment 3+) = cut body
                            else {
                                const cutSegments = snake.segments.splice(s);
                                snake.length = snake.segments.length;
                                
                                // Spawn food from cut segments
                                for (let c = 0; c < cutSegments.length; c += 2) {
                                    const seg = cutSegments[c];
                                    food.push({
                                        x: seg.x,
                                        y: seg.y,
                                        radius: 4,
                                        isPurple: false
                                    });
                                }
                            }
                            
                            venomShots.splice(i, 1);
                            hit = true;
                            break;
                        }
                    }
                    
                    if (hit) break;
                }
                
                // Check collision with player's own body (emergency cut in all modes)
                if (player) {
                    for (let p = 5; p < player.segments.length; p++) {
                        const segment = player.segments[p];
                        const dx = venom.x - segment.x;
                        const dy = venom.y - segment.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < venom.radius + player.segmentRadius) {
                            // Cut player's body at this point
                            const cutSegments = player.segments.splice(p);
                            player.length = player.segments.length;
                            
                            // Spawn food from cut segments
                            for (let c = 0; c < cutSegments.length; c += 2) {
                                const seg = cutSegments[c];
                                food.push({
                                    x: seg.x,
                                    y: seg.y,
                                    radius: 4,
                                    isPurple: false
                                });
                            }
                            
                            venomShots.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // Draw venom
                const screenX = venom.x - camera.x;
                const screenY = venom.y - camera.y;
                
                ctx.fillStyle = '#a020f0';
                ctx.beginPath();
                ctx.arc(screenX, screenY, venom.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#8b008b';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Update weapon cooldowns
            if (laserCooldown > 0) laserCooldown--;
            if (explosiveCooldown > 0) explosiveCooldown--;
            if (mineCooldown > 0) mineCooldown--;
            if (hookCooldown > 0) hookCooldown--;
            if (dashCooldown > 0) dashCooldown--;
            if (poisonTrailCooldown > 0) poisonTrailCooldown--;
            
            // Update and draw laser beams
            for (let i = laserBeams.length - 1; i >= 0; i--) {
                const laser = laserBeams[i];
                laser.lifetime--;
                
                if (laser.lifetime <= 0) {
                    laserBeams.splice(i, 1);
                    continue;
                }
                
                // Check collision with AI snakes
                const endX = laser.x + Math.cos(laser.angle) * laser.length;
                const endY = laser.y + Math.sin(laser.angle) * laser.length;
                
                for (let j = snakes.length - 1; j >= 0; j--) {
                    const snake = snakes[j];
                    for (let s = 0; s < snake.segments.length; s++) {
                        const seg = snake.segments[s];
                        const dist = distanceToLineSegment(seg.x, seg.y, laser.x, laser.y, endX, endY);
                        
                        if (dist < snake.segmentRadius + laser.width) {
                            // Cut snake at this point
                            if (s < 3) {
                                spawnFood(snake.segments[0].x, snake.segments[0].y, snake.length);
                                snakes.splice(j, 1);
                                if (shouldRespawn()) {
                                    const x = Math.random() * WORLD_WIDTH;
                                    const y = Math.random() * WORLD_HEIGHT;
                                    snakes.push(new Snake(x, y, false, '', gameMode === 'tdm' ? snake.team : null));
                                }
                            } else {
                                const cutSegments = snake.segments.splice(s);
                                snake.length = snake.segments.length;
                                for (let c = 0; c < cutSegments.length; c += 2) {
                                    food.push({ x: cutSegments[c].x, y: cutSegments[c].y, radius: 4, isPurple: false });
                                }
                            }
                            break;
                        }
                    }
                }
                
                // Draw laser
                const screenX1 = laser.x - camera.x;
                const screenY1 = laser.y - camera.y;
                const screenX2 = endX - camera.x;
                const screenY2 = endY - camera.y;
                
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = laser.width;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(screenX1, screenY1);
                ctx.lineTo(screenX2, screenY2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Update and draw explosive shots
            for (let i = explosiveShots.length - 1; i >= 0; i--) {
                const explosive = explosiveShots[i];
                explosive.x += Math.cos(explosive.angle) * explosive.speed;
                explosive.y += Math.sin(explosive.angle) * explosive.speed;
                explosive.lifetime--;
                
                if (explosive.lifetime <= 0 || explosive.exploded) {
                    if (!explosive.exploded) {
                        // Explode
                        explosive.exploded = true;
                        const explosionRadius = 80;
                        
                        // Damage all snakes in radius
                        for (let j = snakes.length - 1; j >= 0; j--) {
                            const snake = snakes[j];
                            for (let s = 0; s < snake.segments.length; s++) {
                                const seg = snake.segments[s];
                                const dx = seg.x - explosive.x;
                                const dy = seg.y - explosive.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < explosionRadius) {
                                    if (s < 3) {
                                        spawnFood(snake.segments[0].x, snake.segments[0].y, snake.length);
                                        snakes.splice(j, 1);
                                        if (shouldRespawn()) {
                                            const x = Math.random() * WORLD_WIDTH;
                                            const y = Math.random() * WORLD_HEIGHT;
                                            snakes.push(new Snake(x, y, false, '', gameMode === 'tdm' ? snake.team : null));
                                        }
                                    } else {
                                        const cutSegments = snake.segments.splice(s);
                                        snake.length = snake.segments.length;
                                        for (let c = 0; c < cutSegments.length; c += 2) {
                                            food.push({ x: cutSegments[c].x, y: cutSegments[c].y, radius: 4, isPurple: false });
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    explosiveShots.splice(i, 1);
                    continue;
                }
                
                // Check collision
                for (let j = snakes.length - 1; j >= 0; j--) {
                    const snake = snakes[j];
                    const head = snake.segments[0];
                    const dx = explosive.x - head.x;
                    const dy = explosive.y - head.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < explosive.radius + snake.segmentRadius) {
                        explosive.exploded = true;
                        explosive.lifetime = 1;
                        break;
                    }
                }
                
                // Draw explosive
                const screenX = explosive.x - camera.x;
                const screenY = explosive.y - camera.y;
                ctx.fillStyle = '#ff4500';
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(screenX, screenY, explosive.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // Update and draw mines
            for (let i = mines.length - 1; i >= 0; i--) {
                const mine = mines[i];
                
                if (!mine.armed) {
                    mine.armTime--;
                    if (mine.armTime <= 0) mine.armed = true;
                }
                
                if (mine.armed) {
                    // Check collision
                    for (let j = snakes.length - 1; j >= 0; j--) {
                        const snake = snakes[j];
                        const head = snake.segments[0];
                        const dx = mine.x - head.x;
                        const dy = mine.y - head.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < mine.radius + snake.segmentRadius) {
                            // Explode
                            spawnFood(snake.segments[0].x, snake.segments[0].y, snake.length);
                            snakes.splice(j, 1);
                            if (shouldRespawn()) {
                                const x = Math.random() * WORLD_WIDTH;
                                const y = Math.random() * WORLD_HEIGHT;
                                snakes.push(new Snake(x, y, false, '', gameMode === 'tdm' ? snake.team : null));
                            }
                            mines.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // Draw mine
                const screenX = mine.x - camera.x;
                const screenY = mine.y - camera.y;
                ctx.fillStyle = mine.armed ? '#ff0000' : '#666';
                ctx.shadowColor = mine.armed ? '#ff0000' : 'transparent';
                ctx.shadowBlur = mine.armed ? 15 : 0;
                ctx.beginPath();
                ctx.arc(screenX, screenY, mine.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // Update and draw hooks
            for (let i = hooks.length - 1; i >= 0; i--) {
                const hook = hooks[i];
                
                if (!hook.target) {
                    hook.x += Math.cos(hook.angle) * hook.speed;
                    hook.y += Math.sin(hook.angle) * hook.speed;
                    hook.lifetime--;
                    
                    // Check collision
                    for (let j = 0; j < snakes.length; j++) {
                        const snake = snakes[j];
                        const head = snake.segments[0];
                        const dx = hook.x - head.x;
                        const dy = hook.y - head.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < hook.radius + snake.segmentRadius) {
                            hook.target = snake;
                            break;
                        }
                    }
                    
                    if (hook.lifetime <= 0) {
                        hooks.splice(i, 1);
                        continue;
                    }
                } else {
                    // Pull target towards player
                    if (player && hook.target.segments[0]) {
                        const targetHead = hook.target.segments[0];
                        const playerHead = player.segments[0];
                        const dx = playerHead.x - targetHead.x;
                        const dy = playerHead.y - targetHead.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 50) {
                            targetHead.x += (dx / dist) * 5;
                            targetHead.y += (dy / dist) * 5;
                        } else {
                            hooks.splice(i, 1);
                            continue;
                        }
                    } else {
                        hooks.splice(i, 1);
                        continue;
                    }
                }
                
                // Draw hook
                const screenX = hook.x - camera.x;
                const screenY = hook.y - camera.y;
                ctx.fillStyle = '#ffa500';
                ctx.beginPath();
                ctx.arc(screenX, screenY, hook.radius, 0, Math.PI * 2);
                ctx.fill();
                
                if (hook.target && player) {
                    ctx.strokeStyle = '#ffa500';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(player.segments[0].x - camera.x, player.segments[0].y - camera.y);
                    ctx.lineTo(screenX, screenY);
                    ctx.stroke();
                }
            }
            
            // Update and draw poison trail
            if (poisonTrailActive && player) {
                const head = player.segments[0];
                poisonTrailSegments.push({ x: head.x, y: head.y, lifetime: 300 }); // 5 seconds
            }
            
            for (let i = poisonTrailSegments.length - 1; i >= 0; i--) {
                const trail = poisonTrailSegments[i];
                trail.lifetime--;
                
                if (trail.lifetime <= 0) {
                    poisonTrailSegments.splice(i, 1);
                    continue;
                }
                
                // Check collision with AI
                for (let j = snakes.length - 1; j >= 0; j--) {
                    const snake = snakes[j];
                    for (let s = 0; s < snake.segments.length; s++) {
                        const seg = snake.segments[s];
                        const dx = trail.x - seg.x;
                        const dy = trail.y - seg.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 15) {
                            if (s < 3) {
                                spawnFood(snake.segments[0].x, snake.segments[0].y, snake.length);
                                snakes.splice(j, 1);
                                if (shouldRespawn()) {
                                    const x = Math.random() * WORLD_WIDTH;
                                    const y = Math.random() * WORLD_HEIGHT;
                                    snakes.push(new Snake(x, y, false, '', gameMode === 'tdm' ? snake.team : null));
                                }
                            } else {
                                const cutSegments = snake.segments.splice(s);
                                snake.length = snake.segments.length;
                                for (let c = 0; c < cutSegments.length; c += 2) {
                                    food.push({ x: cutSegments[c].x, y: cutSegments[c].y, radius: 4, isPurple: false });
                                }
                            }
                            break;
                        }
                    }
                }
                
                // Draw trail
                const screenX = trail.x - camera.x;
                const screenY = trail.y - camera.y;
                const alpha = trail.lifetime / 300;
                ctx.fillStyle = `rgba(0, 255, 0, ${alpha * 0.5})`;
                ctx.shadowColor = '#00ff00';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // Draw food
            for (let f of food) {
                if (f.x - camera.x > -50 && f.x - camera.x < canvas.width + 50 &&
                    f.y - camera.y > -50 && f.y - camera.y < canvas.height + 50) {
                    
                    // Add glow for purple food
                    if (f.isPurple) {
                        ctx.shadowColor = f.color;
                        ctx.shadowBlur = 20;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(f.x - camera.x, f.y - camera.y, f.radius, 0, Math.PI * 2);
                    ctx.fillStyle = f.color;
                    ctx.fill();
                    ctx.strokeStyle = f.isPurple ? '#fff' : 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = f.isPurple ? 2 : 1;
                    ctx.stroke();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                }
            }
            
            // Update and draw snakes
            for (let i = snakes.length - 1; i >= 0; i--) {
                const snake = snakes[i];
                snake.update();
                checkFoodCollision(snake);
                
                // Check if AI is in hardpoint (score points slower - every 4 frames)
                if (isHardpointMode()) {
                    const dx = snake.segments[0].x - hardpoint.x;
                    const dy = snake.segments[0].y - hardpoint.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < hardpoint.radius) {
                        // AI scores 0.25 per frame (effectively 1 point every 4 frames)
                        hardpointScore.ai += 0.25;
                    }
                }
                
                // Prevent body overlap with other snakes (check every 5th segment for performance)
                for (let j = 0; j < snakes.length; j++) {
                    if (i === j) continue;
                    const otherSnake = snakes[j];
                    
                    for (let s = 0; s < snake.segments.length; s += 5) {
                        const mySegment = snake.segments[s];
                        for (let o = 0; o < otherSnake.segments.length; o += 5) {
                            const otherSegment = otherSnake.segments[o];
                            const dx = mySegment.x - otherSegment.x;
                            const dy = mySegment.y - otherSegment.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const minDist = mySegment.radius + otherSegment.radius;
                            
                            if (dist < minDist && dist > 0) {
                                // Push segments apart
                                const pushForce = (minDist - dist) * 0.5;
                                const pushX = (dx / dist) * pushForce;
                                const pushY = (dy / dist) * pushForce;
                                
                                mySegment.x += pushX;
                                mySegment.y += pushY;
                                otherSegment.x -= pushX;
                                otherSegment.y -= pushY;
                            }
                        }
                    }
                }
                
                let snakeDied = false;
                
                // Check if AI snake hit player's body (player gets the kill)
                if (player) {
                    // In TDM, only enemy team (red) can be killed by player (blue)
                    const canKill = gameMode !== 'tdm' || snake.team === 'red';
                    
                    if (canKill) {
                        const aiHead = snake.segments[0];
                        
                        // Check collision with each player segment (start from segment 1 for better coverage)
                        for (let j = 1; j < player.segments.length; j++) {
                            const playerSegment = player.segments[j];
                            const dx = aiHead.x - playerSegment.x;
                            const dy = aiHead.y - playerSegment.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            // Increased detection radius for more reliable hits
                            if (dist < (snake.segmentRadius + playerSegment.radius) * 1.2) {
                                // AI snake dies, spawn food
                                spawnFood(snake.segments[0].x, snake.segments[0].y, snake.length);
                                snakes.splice(i, 1);
                                
                                // Spawn new snake (with team in TDM) - not in BR
                                if (shouldRespawn()) {
                                    const x = Math.random() * WORLD_WIDTH;
                                    const y = Math.random() * WORLD_HEIGHT;
                                    const newSnake = new Snake(x, y, false, '', gameMode === 'tdm' ? snake.team : null);
                                    snakes.push(newSnake);
                                }
                                snakeDied = true;
                                break;
                            }
                            
                            // Also check collision with line between this segment and the next
                            if (j < player.segments.length - 1) {
                                const nextSegment = player.segments[j + 1];
                                const lineToPointDist = distanceToLineSegment(
                                    aiHead.x, aiHead.y,
                                    playerSegment.x, playerSegment.y,
                                    nextSegment.x, nextSegment.y
                                );
                            
                            // Increased detection radius
                            if (lineToPointDist < (snake.segmentRadius + playerSegment.radius) * 1.2) {
                                // AI snake dies, spawn food
                                spawnFood(snake.segments[0].x, snake.segments[0].y, snake.length);
                                snakes.splice(i, 1);
                                
                                // Spawn new snake (with team in TDM) - not in BR
                                if (shouldRespawn()) {
                                    const x = Math.random() * WORLD_WIDTH;
                                    const y = Math.random() * WORLD_HEIGHT;
                                    const newSnake = new Snake(x, y, false, '', gameMode === 'tdm' ? snake.team : null);
                                    snakes.push(newSnake);
                                }
                                snakeDied = true;
                                break;
                            }
                        }
                    }
                    }
                }
                
                if (snakeDied) {
                    continue;
                }
                
                snake.draw();
                
                // Check storm damage for AI
                if (checkStormDamage(snake)) {
                    // AI dies from storm
                    spawnFood(snake.segments[0].x, snake.segments[0].y, snake.length);
                    snakes.splice(i, 1);
                    
                    // Don't respawn in BR (shouldn't happen anyway since only BR has storm)
                    // Spawn new snake in other modes
                    if (shouldRespawn()) {
                        const x = Math.random() * WORLD_WIDTH;
                        const y = Math.random() * WORLD_HEIGHT;
                        const newSnake = new Snake(x, y, false, '', gameMode === 'tdm' ? snake.team : null);
                        snakes.push(newSnake);
                    }
                    continue;
                }
                
                // Check if AI snake hit player (detailed collision)
                if (player) {
                    const aiHead = snake.segments[0];
                    
                    // Check collision with player segments
                    for (let p = 0; p < player.segments.length; p++) {
                        const playerSegment = player.segments[p];
                        const dx = aiHead.x - playerSegment.x;
                        const dy = aiHead.y - playerSegment.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < snake.segmentRadius + playerSegment.radius) {
                            // Admin immunity prevents collision
                            if (isAdmin && adminImmune) {
                                break;
                            }
                            
                            // Spawn protection prevents collision
                            if (player.spawnProtection) {
                                break;
                            }
                            
                            // Hit first 3 segments (head area) = death
                            if (p < 3) {
                                if (gameMode === 'ffa' || gameMode === 'battleroyale' || gameMode === 'hardpoint' || gameMode === 'tournament') {
                                    spawnFood(player.segments[0].x, player.segments[0].y, player.length);
                                    endGame();
                                    return;
                                } else if (gameMode === 'tdm' && snake.team === 'red') {
                                    spawnFood(player.segments[0].x, player.segments[0].y, player.length);
                                    endGame();
                                    return;
                                }
                            }
                            // Hit body (segment 3+) = cut body
                            else {
                                if (gameMode !== 'suicide' && gameMode !== 'tdm' || (gameMode === 'tdm' && snake.team === 'red')) {
                                    // Cut player's body at this point
                                    const cutSegments = player.segments.splice(p);
                                    player.length = player.segments.length;
                                    
                                    // Spawn food from cut segments
                                    for (let i = 0; i < cutSegments.length; i += 2) {
                                        const seg = cutSegments[i];
                                        food.push({
                                            x: seg.x,
                                            y: seg.y,
                                            radius: 4,
                                            isPurple: false
                                        });
                                    }
                                }
                            }
                            break;
                        }
                    }
                }
                
                // Check if AI snake hit other AI snakes (game mode dependent)
                if (gameMode === 'ffa' || gameMode === 'suicide' || gameMode === 'battleroyale' || gameMode === 'hardpoint' || gameMode === 'tournament') {
                    // In FFA, SUICIDE, BR, HARDPOINT, and TOURNAMENT, AI snakes kill each other
                    for (let k = snakes.length - 1; k >= 0; k--) {
                        const otherSnake = snakes[k];
                        if (snake !== otherSnake && snake.checkCollision(otherSnake)) {
                            // Snake dies
                            spawnFood(snake.segments[0].x, snake.segments[0].y, snake.length);
                            snakes.splice(i, 1);
                            
                            // Spawn new snake - not in BR
                            if (shouldRespawn()) {
                                const x = Math.random() * WORLD_WIDTH;
                                const y = Math.random() * WORLD_HEIGHT;
                                const newSnake = new Snake(x, y, false);
                                snakes.push(newSnake);
                            }
                            break;
                        }
                    }
                } else if (gameMode === 'tdm') {
                    // In TDM, only enemy teams can kill each other
                    for (let k = snakes.length - 1; k >= 0; k--) {
                        const otherSnake = snakes[k];
                        if (snake !== otherSnake && snake.team !== otherSnake.team && snake.checkCollision(otherSnake)) {
                            // Snake dies
                            spawnFood(snake.segments[0].x, snake.segments[0].y, snake.length);
                            snakes.splice(i, 1);
                            
                            // Spawn new snake on same team
                            const x = Math.random() * WORLD_WIDTH;
                            const y = Math.random() * WORLD_HEIGHT;
                            const newSnake = new Snake(x, y, false, '', snake.team);
                            snakes.push(newSnake);
                            break;
                        }
                    }
                }
            }
            
            // Update and draw player
            if (player) {
                player.update(mouseX, mouseY);
                checkFoodCollision(player);
                player.draw();
                
                // Check storm damage
                if (checkStormDamage(player)) {
                    // Admin immunity prevents storm death
                    if (isAdmin && adminImmune) {
                        // Do nothing - immune!
                    } else {
                        // Player dies from storm
                        spawnFood(player.segments[0].x, player.segments[0].y, player.length);
                        endGame();
                        return;
                    }
                }
                
                // Check if player hit other snakes (game mode dependent)
                for (let snake of snakes) {
                    if (player.checkCollision(snake)) {
                        // Admin immunity prevents collision death
                        if (isAdmin && adminImmune) {
                            continue; // Skip damage
                        }
                        
                        // Spawn protection prevents collision death
                        if (player.spawnProtection) {
                            continue; // Skip damage
                        }
                        
                        if (gameMode === 'ffa' || gameMode === 'battleroyale' || gameMode === 'hardpoint' || gameMode === 'tournament') {
                            // FFA/BR/HARDPOINT/TOURNAMENT: player hitting AI = player dies
                            spawnFood(player.segments[0].x, player.segments[0].y, player.length);
                            endGame();
                            return;
                        } else if (gameMode === 'tdm') {
                            // TDM: only hitting enemy team (red) kills player
                            if (snake.team === 'red') {
                                spawnFood(player.segments[0].x, player.segments[0].y, player.length);
                                endGame();
                                return;
                            }
                            // Same team (blue) = no collision
                        } else if (gameMode === 'suicide') {
                            // SUICIDE: player doesn't die hitting AI
                            // Do nothing
                        }
                    }
                }
                
                // SUICIDE MODE: Check if player hit themselves
                if (gameMode === 'suicide') {
                    const head = player.segments[0];
                    for (let i = 5; i < player.segments.length; i++) {
                        const segment = player.segments[i];
                        const dx = head.x - segment.x;
                        const dy = head.y - segment.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < player.segmentRadius * 2) {
                            // Admin immunity prevents self-collision death
                            if (isAdmin && adminImmune) {
                                continue; // Skip damage
                            }
                            // Player hit themselves - GAME OVER
                            spawnFood(player.segments[0].x, player.segments[0].y, player.length);
                            endGame();
                            return;
                        }
                    }
                }
                
                // Update HUD
                document.getElementById('length').textContent = player.length;
                
                // Update weapon display
                const weaponNames = ['', 'VENOM', 'LASER', 'EXPLOSIVE', 'MINE', 'HOOK', 'DASH', 'POISON TRAIL'];
                document.getElementById('weaponName').textContent = weaponNames[currentWeapon];
                
                // Update weapon bar glow
                document.querySelectorAll('.weapon-slot').forEach(slot => {
                    slot.classList.remove('active');
                });
                const activeSlot = document.querySelector(`.weapon-slot[data-weapon="${currentWeapon}"]`);
                if (activeSlot) {
                    activeSlot.classList.add('active');
                }
                
                // Update hardpoint scores in HUD
                if (gameMode === 'hardpoint') {
                    const multiplierText = playerMultiplier > 1 ? ` (${playerMultiplier.toFixed(1)}x)` : '';
                    document.getElementById('length').textContent = `YOU: ${Math.floor(hardpointScore.player)}${multiplierText} | AI: ${Math.floor(hardpointScore.ai)}`;
                }
                
                // Update boost bar
                const boostPercent = (player.boost / player.maxBoost) * 100;
                document.getElementById('boostBar').style.width = boostPercent + '%';
            }
            
            updateCamera();
            updateLeaderboard();
            
            // Check for victory in Hardpoint/Tournament mode (last player standing)
            if (isHardpointMode() && player && snakes.length === 0) {
                victory();
                return;
            }
            
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Disable right-click context menu
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });
        
        // Disable F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U, Ctrl+Shift+C
        document.addEventListener('keydown', (e) => {
            // F12
            if (e.key === 'F12') {
                e.preventDefault();
                return false;
            }
            
            // Ctrl+Shift+I (Inspect)
            if (e.ctrlKey && e.shiftKey && e.key === 'I') {
                e.preventDefault();
                return false;
            }
            
            // Ctrl+Shift+J (Console)
            if (e.ctrlKey && e.shiftKey && e.key === 'J') {
                e.preventDefault();
                return false;
            }
            
            // Ctrl+U (View Source)
            if (e.ctrlKey && e.key === 'u') {
                e.preventDefault();
                return false;
            }
            
            // Ctrl+Shift+C (Inspect Element)
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                return false;
            }
            
            // Ctrl+S (Save Page)
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                return false;
            }
        });
        
        // Disable text selection
        document.addEventListener('selectstart', (e) => {
            if (gameStarted) {
                e.preventDefault();
                return false;
            }
        });
        
        // Disable drag
        document.addEventListener('dragstart', (e) => {
            e.preventDefault();
            return false;
        });
        
        // Weapon slot click handlers
        document.querySelectorAll('.weapon-slot').forEach(slot => {
            slot.addEventListener('click', function() {
                const weaponNum = parseInt(this.getAttribute('data-weapon'));
                currentWeapon = weaponNum;
                
                // Update active class
                document.querySelectorAll('.weapon-slot').forEach(s => s.classList.remove('active'));
                this.classList.add('active');
            });
        });
        
        // Set initial weapon as active
        const initialSlot = document.querySelector('.weapon-slot[data-weapon="1"]');
        if (initialSlot) {
            initialSlot.classList.add('active');
        }
    </script>
</body>
</html>
